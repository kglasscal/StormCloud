---
title: 'Severe Weather: Preparing for Emergency Response'
author: "Kevin Glass"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
    toc_depth: 3
    number_sections: yes
    toc_float:
      toc_collapsed: yes
    theme: united
---

```{r knitr setup}

knitr::opts_chunk$set(echo = TRUE)
options(max.print = 1000000)

```


```{=html}
<div style="font-size : 12; color: black; font-weight: normal;">  <!-- Base page -->
```

# Synopsis

This document is designed to assist emergency response organizations to prepare for severe weather events in the United States. With tornadoes in the Midwest, hurricanes in the Gulf Coast and Eastern Seaboard, severe winter storms in the Mountain West, etc., require these organizations to deal with different relief needs in differing geographical areas. In particular, weather events can cause human casualties (injuries and deaths), economic losses (property or crop damage), or both. Using historical data provided by National Oceanographic and Atmospheric Agency (NOAA) Storm Events Database [1], the project can assess some damages caused by each type of event. 


To analyze the Storm Events Database, the historical data was cleaned the; data making no contribution to the analysis were removed; and all of the event names conformed to the National Weather Service (NWS) Instruction 10-1605 [2]. This data set generates a pair of data frames, one with the events ordered by casualties and the other by economic losses. The data frames are presented to the user through tables and images. 

These presentations will provide the user with information about the potential for damage due to individual weather events, in addition which events cause the most damage. The user can set priorities, set resource staging requirements, and prepare ahead of time for severe weather events.


# Data Processing

## Data Transformations

The analysis is designed to answer two questions:

1. **Across the United States, which types of events are most harmful with respect to population health?**
2. **Across the United States, which types of events have the greatest economic consequences?**

To answer these questions, specific data fields must be copied from the storm events file and the analysis eventually groups the data by the event type and stored in a data frame. The grouped data is copied into two data frames, one ordered by casualties (population health) and the other by economic losses (economic consequences). This data will provide emergency planners with information about the severity of each weather event.

To get the data into an appropriate structure requires several transformations. Some of these transformations are complex and require detailed explanation others should be straightforward. This section will describe why a change is needed, how it is done, and the impact on the data frames.

The code will follow the transformation descriptions. The code is divided into three categories: the set up blocks, the transformation blocks and the output blocks. The set up blocks include the libraries required by the code and a set of "constant" variables; the transformation blocks convert the storm file data into complete tables ready for the analysis; the output blocks generate the tables and images required by the presentation.

### Glossary
Before describing the transformations, planners need to familiarize themselves with some of the nomenclature used in the document.

**NWS Names** are the type names found in National Weather Service (NWS) Instruction 10-1605 [2]. 

**initial data fields** -- *EVTYPE*, *FATALITIES*, *INJURIES*, *PROPDMG*, *PROPDMGEXP*, *CROPDMG*, and *CROPDMGEXP*. These fields, read directly from the file, include all of the information required to perform the analysis.

**numeric fields**  *FATALITIES*, *INJURIES*, *PROPDMG*, and *CROPDMG* hold the numeric values required by the analysis.

**exponent fields** *PROPDMGEXP* and *CROPDMGEXP* are character values representing numerical values. The letter 'k' represents 1,000, and the letter 'M' represents 1,000,000.

**independent field** -- *EVTYPE* identifies a specific set of numeric fields each data frame.   

**damage types** are *casualties* and *economic losses*. Casualties represent the harm done by each weather event and ecoonomic losses represent the economic consequences. For this analysis:

1. *CASUALTIES* = *FATALITIES* + *INJURIES*,
2. *ECONOMIC LOSSES* = (*PROPDMG* * *PROPDMGEXP*) + (*CROPDMG* * *CROPDMGEXP*).

**unifying names** is the process ensuring all names used by the data collectors are replaced with the appropriate NWS type names.

<hr style="background : #6D0500; height : 15px"/>


### Transformation 0: No transformations

**Goal**

The goal for Transformation 0, is to provide a baseline for analyzing the effect of each transformation on the data frame (or tibble).

**Why?**

Reading the complete data set from the storm file, will provide state information regarding the memory required to store the data, the dimensions of the data, the number of unique events and the first ten rows of the data frame.

**How?**

The Transformation 0 block is only used to get baseline data, so the entire computation is enclosed by an if statement, it block executes when two "constants", *VERBOSE* and *ALL_DATA*, are TRUE. When it executes, it reads the entire storm data file into a data frame and prints out the state data. Since the only point of this code block is to print the state of the data frame, it terminates once the statement is done.

**Consequences**

```{=html}
<div style="font-size : 14;">

<strong>Output Listing 0</strong> The Transform 0 block output shows the full data frame is 902297 by 37, it requires 494 MB of memory, and there are 985 different event types. It is important to note, the NWS naming conventions have 47 distinct event types.  

<pre>
## [1] "Transformation 0"
## [1] "Number of unique event names         985"
## [1] "The data frame memory requirement is 494295216"
## [1] "The data frame dimensions are        902297"
## [2] "The data frame dimensions are        37"    

##    STATE__           BGN_DATE BGN_TIME TIME_ZONE COUNTY COUNTYNAME STATE
## 1        1  4/18/1950 0:00:00     0130       CST     97     MOBILE    AL
## 2        1  4/18/1950 0:00:00     0145       CST      3    BALDWIN    AL
## 3        1  2/20/1951 0:00:00     1600       CST     57    FAYETTE    AL
## 4        1   6/8/1951 0:00:00     0900       CST     89    MADISON    AL
## 5        1 11/15/1951 0:00:00     1500       CST     43    CULLMAN    AL
## 6        1 11/15/1951 0:00:00     2000       CST     77 LAUDERDALE    AL
## 7        1 11/16/1951 0:00:00     0100       CST      9     BLOUNT    AL
## 8        1  1/22/1952 0:00:00     0900       CST    123 TALLAPOOSA    AL
## 9        1  2/13/1952 0:00:00     2000       CST    125 TUSCALOOSA    AL
## 10       1  2/13/1952 0:00:00     2000       CST     57    FAYETTE    AL
## .        .       .       .          .         .      .        .        .
## .        .       .       .          .         .      .        .        .
## .        .       .       .          .         .      .        .        .
##     EVTYPE BGN_RANGE BGN_AZI BGN_LOCATI END_DATE END_TIME COUNTY_END COUNTYENDN
## 1  TORNADO         0     .       .          .        .             0         NA
## 2  TORNADO         0     .       .          .        .             0         NA
## 3  TORNADO         0     .       .          .        .             0         NA
## 4  TORNADO         0     .       .          .        .             0         NA
## 5  TORNADO         0     .       .          .        .             0         NA
## 6  TORNADO         0     .       .          .        .             0         NA
## 7  TORNADO         0     .       .          .        .             0         NA
## 8  TORNADO         0     .       .          .        .             0         NA
## 9  TORNADO         0     .       .          .        .             0         NA
## 10 TORNADO         0     .       .          .        .             0         NA
## .     .            .     .       .          .        .             .         .
## .     .            .     .       .          .        .             .         .
## .     .            .     .       .          .        .             .         .
##    END_RANGE END_AZI END_LOCATI LENGTH WIDTH F MAG FATALITIES INJURIES PROPDMG
## 1          0    .       .         14.0   100 3   0          0       15    25.0
## 2          0    .       .          2.0   150 2   0          0        0     2.5
## 3          0    .       .          0.1   123 2   0          0        2    25.0
## 4          0    .       .          0.0   100 2   0          0        2     2.5
## 5          0    .       .          0.0   150 2   0          0        2     2.5
## 6          0    .       .          1.5   177 2   0          0        6     2.5
## 7          0    .       .          1.5    33 2   0          0        1     2.5
## 8          0    .       .          0.0    33 1   0          0        0     2.5
## 9          0    .       .          3.3   100 3   0          1       14    25.0
## 10         0    .       .          2.3   100 3   0          0        0    25.0
## .          .    .       .          .         .      .        .        .     .
## .          .    .       .          .         .      .        .        .     .
## .          .    .       .          .         .      .        .        .     .
##    PROPDMGEXP CROPDMG CROPDMGEXP WFO STATEOFFIC ZONENAMES LATITUDE LONGITUDE
## 1           K       0      .            .         .           3040      8812
## 2           K       0      .            .         .           3042      8755
## 3           K       0      .            .         .           3340      8742
## 4           K       0      .            .         .           3458      8626
## 5           K       0      .            .         .           3412      8642
## 6           K       0      .            .         .           3450      8748
## 7           K       0      .            .         .           3405      8631
## 8           K       0      .            .         .           3255      8558
## 9           K       0      .            .         .           3334      8740
## 10          K       0      .            .         .           3336      8738
## .           .       .      .            .         .             .         .
## .           .       .      .            .         .             .         .
## .           .       .      .            .         .             .         .
##    LATITUDE_E LONGITUDE_ REMARKS REFNUM
## 1        3051       8806              1
## 2           0          0              2
## 3           0          0              3
## 4           0          0              4
## 5           0          0              5
## 6           0          0              6
## 7           0          0              7
## 8           0          0              8
## 9        3336       8738              9
## 10       3337       8737             10
## .          .          .               .
## .          .          .               .
## .          .          .               .
</pre>
</div>
```

**Consequences**

* The zero transformation requires roughly 500 MB
* The data frame has dimensions 902297 rows by 37 columns.
* There were 985 distinct event names at this point.

<hr style="background : #F7261C; height : 15px"/>

### Transformation 1: Reading the data file

**Goal**

The goal of this transformation is read select fields from the storm data file into a the *sourceDF* data frame.

**Why?**

The source file contains more data than what is needed for this project. By selecting the only the required columns, the *sourceDF* will have all of the data it requires and nothing more.  

The data analysis requires the numerical data for each event type *EVTYPE* need to calculate the harm done to the public and the economic losses. The required data is the **initial data fields** described in the Glossary Section.

**How?**

The Transformation 2 code block reads the storm data file selecting the required columnsusing the colClasses argument and stores the result in *sourceData*.

**Consequences**

```{=html}

<div style="font-size : 14;">

<strong>Output Listing 1:</strong> The Transform 1 block output shows the full data frame is 902297 by 7, it requires 51 MB of memory, and there are 985 different event types.

<pre>
## [1] "Transformation 1"
## [1] "Number of unique event names 985"
## [1] "The data frame memory requirement is 50601984"
## [1] "The data frame dimensions are        902297"
## [2] "The data frame dimensions are        7"     
##     EVTYPE FATALITIES INJURIES PROPDMG PROPDMGEXP CROPDMG CROPDMGEXP
## 1  TORNADO          0       15    25.0          K       0      .          
## 2  TORNADO          0        0     2.5          K       0      .
## 3  TORNADO          0        2    25.0          K       0      .           
## 4  TORNADO          0        2     2.5          K       0      .    
## 5  TORNADO          0        2     2.5          K       0      .    
## 6  TORNADO          0        6     2.5          K       0      .    
## 7  TORNADO          0        1     2.5          K       0      .
## 8  TORNADO          0        0     2.5          K       0      .
## 9  TORNADO          1       14    25.0          K       0      .    
## 10 TORNADO          0        0    25.0          K       0      .
##  .    .             .        .      .           .       .      .
##  .    .             .        .      .           .       .      .
##  .    .             .        .      .           .       .      .
##       
 </pre>
</div>

```

**Changes to data frame properties**

* After Transformation 1, *sourceDF* requires roughly 51 MB, or a decrease of 453 MB from the complete data frame
* The data frame has dimensions 902297 rows by 7 columns, or a reduction of 30 columns.
* There are 985 distinct event names at this point, which is the same as the complete data set.

The drop in memory usage is due to the reduction in the number of columns in the transformed data frame. This reduction should improve the execution time of the code.

<hr style="background : #F7AB1C; height : 15px"/>

### Transformation 2: Removing non-contributing data points

**Goal**

The goal of Transformation 2 is to remove data points (rows) that do not contribute to the numerical results of the analysis.

**Why?**

The analysis will sum the values of the **numeric fields** but cursory examination of the data shows thousands of data points with *FATALITIES* = 0, *INJURIES* = 0, *PROPDMG* = 0, and *CROPDMG*= 0. None of these values will contribute change the values of the sums, so there is no reason in including them.

**How?**

The data is copied from *sourceDF* to *sourceDF* excluding the non-contributing points. 

NOTE: a side effect of this transformaion is several irrelevant data points are dropped from the data frame.

**Consequences**


```{=html}
<div style="font-size : 14;">
<strong>Output Listing 2a:</strong>Before the execution of Transformation 2, the <em>sourceDF</em> data frame has several unusual values. Three of the values are shown in the listing, each will demonstrate the changes made by the tranformation. 

<ol>
<li>In line 82, "HAIL" is non-contributing because *FATALITIES* = 0, *INJURIES* = 0, *PROPDMG* = 0, and *CROPDMG*= 0, so it will not change the value of any sums. However, there are several "Hail" events, so there should be at least one instance after the transformation</li>
<li>In line 246124, "?" is an invalid event name, but *PROPDMG* = 5, so it contributes to a sum.</li>
<li>In line 271399, "Summary: Nov. 16" is an invalid event name, and it is non-contributing.</li>
</ol>

<pre>

## [1] "Before Transformation 2"
##                  EVTYPE FATALITIES INJURIES PROPDMG PROPDMGEXP CROPDMG CROPDMGEXP
##     82             HAIL          0        0       0          .       0          .
##      .                .          .        .       .          .       .          .
##      .                .          .        .       .          .       .          .
## 246124                ?          0        0       5          K       0          .
##      .                .          .        .       .          .       .          .
##      .                .          .        .       .          .       .          .
## 271399 Summary: Nov. 16          0        0       0                  0          .
##      .                .          .        .       .          .       .          .
##      .                .          .        .       .          .       .          .
##      .                .          .        .       .          .       .          .

</pre>

<strong>Listing 2b:</strong> The output listing after transformation 2 shows several changes to the data frame's state. The memory requirement has decreased, the number of the rows has decreased and the number of unique event names has decreased. 

The changes to the events in 2a are as follows:

<ol>
<li>There is at least on instance of "HAIL" left in the data frame. This is the expected result.</li>
<li>The "?" event is still in the data frame because it contributes to a sum.</li>
<li>The "Summary: Nov. 16" is no longer in the data frame.</li>
</ol>

These are the expected results, which implies the transformation worked as expected.

<pre>
## [1] "Transformation 2"
## [1] "The data frame memory requirement is 15315016"
## [1] "The data frame dimensions are 254633"
## [2] "The data frame dimensions are 7"     
## [1] "Number of unique event names 488"
##     EVTYPE FATALITIES INJURIES PROPDMG PROPDMGEXP CROPDMG CROPDMGEXP
## 1  TORNADO          0       15    25.0          K       0          .
## 2  TORNADO          0        0     2.5          K       0          .
## 3  TORNADO          0        2    25.0          K       0          .
## 4  TORNADO          0        2     2.5          K       0          .
## 5  TORNADO          0        2     2.5          K       0          .
## 6  TORNADO          0        6     2.5          K       0          .
## 7  TORNADO          0        1     2.5          K       0          .
## 8  TORNADO          0        0     2.5          K       0          .
## 9  TORNADO          1       14    25.0          K       0          .
## 10 TORNADO          0        0    25.0          K       0          .
## [1] "CORRECT: HAIL found"
## [1] "CORRECT: ? found"
## [1] "CORRECT: Summary: Nov. 16 not found"
</pre>


```

**Changes to data frame properties**

* After Transformation 3, *sourceDF* requires roughly 15 MB, or a decrease of 438 MB.
* The data frame has dimensions 254633 rows by 7 columns, or a reduction of 647664 columns.
* There are 488 distinct event names at this point, which is a reduction of 497 event names.

The loss of roughly 650,000 rows suggests the storm data file has a lot of non-contributing data points. Moreover, the loss of 497 events names strongly suggests that many of the non-contributing data points did not match valid event names. This is not unexpected because the transformation dropped names like "Summary: Nov. 16." 

With these changes in both the memory requirements and the decrease in the number of rows, the resulting data frame should produce a faster execution time in subsequent transformations.

<hr style="background : #F7F71C; height : 15px"/>

### Transformation 3: Clear white spaces from strings

**Goal**

The goal is to change the string names to simplify comparisons that will have to be done to convert the data collectors names to NWS names.

**Why?**

This transformation is necessary for two reasons. First, white space at the beginning and ending of a string are included in string comparisons. When a name like "DUST" is compare to " DUST" the string will not match, even though they should. The second reason is the data collectors did not use consistent spelling or case usage. Names like *Black Ice* match the NWS naming convention, but *BLACK ICE* does not. Given the number of misspellings, inconsistent names, and other problems, all of the letters in a name are converted to lower case to improve subsequent execution. After the transformation, *Black Ice* and *BLACK ICE* are both spelled *black ice*.


**How?**

Each column of the <em>sourceDF</em> back to sourceDF after triming the white space using *trimws* and converting all strings to lower case letters using *tolower*.

**Consequences**

```{=html}
<strong>Output Listing 3a:</strong> Before the execution of Transformation 3, the code executes an searches for the string " FLASH FLOOD" in the <em>sourceDF$EVTYPE</em> column. The output shows the string was found. The string is not a valid name because of the leading space. The correct name is "FLASH FLOOD".

<pre>

## [1] " FLASH FLOOD found"

</pre>

<strong>Output Listing 3b:</strong> After the execution of Transformation 3, the listing shows the <em>EVTYPE</em>, <em>PROPDMGEXP</em>, and <em>CROPDMGEXP</em> have been converted to strings with all lower case letters.

<pre>
## [1] "Transformation 3"
## [1] "The data frame memory requirement is 15311912"
## [1] "The data frame dimensions are 254633"
## [2] "The data frame dimensions are 7"     
## [1] "Number of unique event names 444"

##     EVTYPE FATALITIES INJURIES PROPDMG PROPDMGEXP CROPDMG CROPDMGEXP
## 1  tornado          0       15    25.0          k       0          .
## 2  tornado          0        0     2.5          k       0          .
## 3  tornado          0        2    25.0          k       0          .
## 4  tornado          0        2     2.5          k       0          .
## 5  tornado          0        2     2.5          k       0          .
## 6  tornado          0        6     2.5          k       0          .
## 7  tornado          0        1     2.5          k       0          .
## 8  tornado          0        0     2.5          k       0          .
## 9  tornado          1       14    25.0          k       0          .
## 10 tornado          0        0    25.0          k       0          .
##  ..   .             .        .      .           .       .          .
##  ..   .             .        .      .           .       .          .
##  ..   .             .        .      .           .       .          .
</pre>

<strong>Output Listing 3c:</strong> In addition to the change in letters, it searched for " FLASH FLOOD", "FLASH FLOOD", " flash flood", and "flash flood". All of the names with the exception of "flash flood" were not found. Since the white spaces were trimmed and all of the characters were changed to lower case letters, this makes sense.

<pre>

## [1] " FLASH FLOOD not found"
## [1] "FLASH FLOOD not found"
## [1] " flash flood not found"
## [1] "flash flood found"
</pre>
</div>
```


**Changes to data frame properties**


* After Transformation 4, *sourceDF* requires still requires roughly 15 MB, but there was a change of about 3 kB.
* The data frame has dimensions 254633 rows by 7 columns remains unchanged.
* There are 444 distinct event names at this point, which is a reduction of 44 event names.

The modest change in the memory required to store *sourceDF* is not surprising. The leading and trailing white space was removed so the small decrease in size is expected. Likewise, names like " FLASH FLOOD" and "FLASH FLOOD" were both converted to "flash flood" and thereby reduced the number of events.


<hr style="background : #009E11; height : 15px"/>

### Transformation 4: Fixing invalid names

**Goal**

The goal is to ensure any contributing events with no apparent relationship to the NWS names are accounted for.

**Why?**

Some of the data collector names have no apparent relationship to the NWS names. For example, the names, **?**, **apache county**, and **high** do not match the any name in the NWS. If they were removed from the data frame, their impact on subsequent calculations would be lost, so every invalid event name was changed to **Other** to ensure they don't create unnecessary *EVTYPE*.

**How?**

Each *EVTYPE* name in *sourceDF* is compared to the invalid names. If a name matches one of the invalid names, the data frame's event name is replaced with the word **Other**.

**Consequences**

```{=html}
<strong>Output Listing 4a:</strong> 

The listing shows the output of the data before Transform 4, which matches the 3b listing with the exception of row named 246124. This row is the only row that contains the '?' event. Using **which(rownames(sourceDF) == 246124)**, the location of the row was determined to be 52498.

<div style="font-size : 14; font-weight: bold;">
<pre>
##        EVTYPE FATALITIES INJURIES PROPDMG PROPDMGEXP CROPDMG CROPDMGEXP
## 246124      ?          0        0       5          k       0           
## [1] 52498
</pre>

<strong>Output Listing 4b:</strong> After Transform 4, the value of  52498. This row's EVTYPE was '?' before the transformation and is 'Other' after.

<pre>
## 15311608 bytes
## [1] 254633      7
##         EVTYPE FATALITIES INJURIES PROPDMG PROPDMGEXP CROPDMG CROPDMGEXP
##      1 tornado          0       15    25.0          k       0          .
##      2 tornado          0        0     2.5          k       0          .
##      3 tornado          0        2    25.0          k       0          .
##      4 tornado          0        2     2.5          k       0          .
##      5 tornado          0        2     2.5          k       0          .
##      6 tornado          0        6     2.5          k       0          .
##      .    .             .        .      .           .       .          .
##      .    .             .        .      .           .       .          .
##      .    .             .        .      .           .       .          .
## 246124 Other            0        0       5          k       0          .
##      .    .             .        .      .           .       .          .
##      .    .             .        .      .           .       .          .

</pre>
</div>


```


**Changes to data frame properties**

* The *sourceDF* before renaming the event names was 15311912 Bytes (~15 MB) of memory and had 254633 rows by 7 columns.
* After renaming the event names, the *sourceDF* date frame size was 15311608 Bytes and dimensions were unchanged.
* The transformation reduces the data frame size by roughly 304 B.
* There were 439 distinct event names making a reduction of 5 event names.

<hr style="background : #004FEE; height : 15px"/>

### Transformation 5:  Unify the event names

**Goal**

The goal is to make every EVTYPE name consistent with the NWS names.

**Why?**

The data collectors used idiosyncratic names for weather events. For example, the NWS event "Thunderstorm Wind" was reported as the following

```{=html}
  <div style="font-size : 8px; font-weight: bold;"> <!-- Thunder storm events -->
```
THUDERSTORM WINDS, THUNDEERSTORM WINDS, THUNDERESTORM WINDS, THUNDERSTORM, THUNDERSTORM  WINDS, Thunderstorm Wind, THUNDERSTORM WIND, THUNDERSTORM WIND (G40), THUNDERSTORM WIND 50, THUNDERSTORM WIND 52,  THUNDERSTORM WIND 56, THUNDERSTORM WIND 59, THUNDERSTORM WIND 59 MPH, THUNDERSTORM WIND 59 MPH., THUNDERSTORM WIND 60 MPH,THUNDERSTORM WIND 65 MPH, THUNDERSTORM WIND 65MPH, THUNDERSTORM WIND 69, THUNDERSTORM WIND 98 MPH, THUNDERSTORM, THUNDERSTORM WIND G55, THUNDERSTORM WIND G60,  THUNDERSTORM WIND G61, THUNDERSTORM WIND TREES, THUNDERSTORM WIND. THUNDERSTORM WIND/ TREE, THUNDERSTORM WIND/ TREES, THUNDERSTORM WIND/AWNING, THUNDERSTORM WINDS, THUNDERSTORM WINDS, THUNDERSTORM WINDS 13, THUNDERSTORM WINDS 2, THUNDERSTORM WINDS 50, THUNDERSTORM WINDS 52, THUNDERSTORM WINDS 53, THUNDERSTORM WINDS 60, THUNDERSTORM WINDS 61, THUNDERSTORM WINDS 62, THUNDERSTORM WINDS 63 MPH, THUNDERSTORM WINDS G, THUNDERSTORMWINDS G60, THUNDERSTORM WINDS., THUNDERSTORM WINDS53, THUNDERSTORMS WIND, THUNDERSTORMS WINDS, THUNDERSTORMW, THUNDERSTORMW 50, THUNDERSTORMW WINDS, THUNDERSTORMWINDS, THUNDERSTROM WIND, THUNDERSTROM WINDS, THUNDERTORM WINDS, THUNDERTSORM WIND,  THUNDESTORM WINDS, THUNERSTORM WINDS, TSTM, TSTM WIND, Tstm Wind, TSTM WIND,  TSTM WIND  (G45), TSTM WIND (41), TSTM WIND (G35), TSTM WIND (G40),  TSTM WIND (G45), TSTM WIND (G45), TSTM WIND 40, TSTM WIND 45, TSTM WIND 50, TSTM WIND 51, TSTM WIND 52, TSTM WIND 55, TSTM WIND 65), TSTM WIND DAMAGE, TSTM WIND G45, TSTM WIND G58, TSTM WINDS, TSTM WND, TSTMW
```{=html}
  </div> 
```
If these names are not unified with a consistent naming convention, then the "Thunderstorm Wind" damage contribution will be spread over 78 events. The results will be skewed if this happens and the result will be incorrect. To fix this problem, Transformation 5 will change all of the variations to "Thunderstorm Wind."

The NWS names are standardized and used to describe events in the NOAA Storm Events Database. The database is used by government agencies and private institutions for weather forecasting, emergency services, and other weather related purposes. Given the ubiquity of the database and the role the NWS event names play in it, the NWS names seem like a logic choice for standardization.  

**How?**

The UnifyNames function will check each name against a set of regular expressions. These REs were set up by printing the 439 events found in Transformation 4. After identifying the NWS event name using a spreadsheet, the REs were created to translate the data collector's names to the NWS names. This information was implemented in the UnifyNames function and the result was stored in *validDF*.

**Consequences**

Listing 5 shows partial results of the unifying names Prior to unifing the first event name was "tornado". After unifying the names, the first eavent became "Tornado", which is the correct NWS name.

In addition to the name changes, further analysis showed that the number of distinct event names went from 239 to 48. This is the result of unifying the names.

```{=html}
<strong>Listing 5: </strong>.

<div style="font-size : 14; font-weight: bold;">
<pre>
## 15283744 bytes
## [1] 254633      7
##    EVTYPE FATALITIES INJURIES PROPDMG PROPDMGEXP CROPDMG CROPDMGEXP
## 1 Tornado          0       15    25.0          k       0           
## 2 Tornado          0        0     2.5          k       0           
## 3 Tornado          0        2    25.0          k       0           
## 4 Tornado          0        2     2.5          k       0           
## 5 Tornado          0        2     2.5          k       0           
## 6 Tornado          0        6     2.5          k       0           
## [1] "unique names 48"

</pre>
</div>
```

**Changes to data frame properties**

* The *sourceDF* before renaming the event names was 15311912 Bytes (~15 MB) of memory and had 254633 rows by 7 columns.
* store *sourceDF* as *validDF*
* After renaming the event names, the *validDF* date frame size was 15283744 Bytes and dimensions were unchanged.
* The transformation reduces the data frame size by roughly 8168 bytes.
* There were 439 distinct event names after Transition 4, and there ae 48 names after Transition 5 making a reduction of 381 event names.

The NWS lists 47 unique weather event names and Transformation 5 reduces its list to 48 events. The difference is due to Transition 4 where several invalid names were changed to **Other**. 

<hr style="background : #5C05FE; height : 15px"/>

### Transformation 6: Set up the analysis data frame

**Goal**

The goal of this Transformation is to add a new field for the total casualties problems and another for economic problems.

**Why?**

To answer the required questions, the analysis must include estimates for casualties and economic consequences due to weather events. However, the source file do not include a column for either estimate. To create the estimates, the Transform uses the data supplied by the storm file to compute *CASUALTIES* and *ECONOMIC* events as follows:

* casualties (CASUALTIES) are FATALITIES + INJURIES
* economic costs (ECONOMIC) are PROPDMG * PROPDMGEXP + CROPDMG * CROPDMGEXP


**How?**

The *validDF* is copied to *analysisDF*. The copy includes mutating the initial data frame as follows:

1. *PROPDMGEXP* and *CROPDMGEXP* are converted from letter representations k and m to numeric values 1,000 and 1,000,000 respectively.
2. The values of *PROPDMG* and *CROPDMG* are multiplied by their respective exponents.
3. The *CASUALTIES* field is set to FATALITIES + INJURIES.
4. The *ECONOMIC* field is set to (PROPDMG + CROPDMG)/1,000,000. Scaling the *ECONOMIC* value by 1,000,000 makes the output tables and images clearer.
5. The *FATALITIES*, *INJURIES*, *PROPDMG*, *PROPDMGEXP*, *CROPDMG*, and *CROPDMGEXP* are droped from the *analysisDF* because they are no longer needed.


**Consequences**

```{=html}
<strong>Listing 6: </strong>.
<div style="font-size : 14; font-weight: bold;">
<pre>
## 7133864 bytes
## [1] 254633      3
##    EVTYPE CASUALTIES ECONOMIC
## 1 Tornado     15   0.0250
## 2 Tornado      0   0.0025
## 3 Tornado      2   0.0250
## 4 Tornado      2   0.0025
## 5 Tornado      2   0.0025
## 6 Tornado      6   0.0025
   .    .         .      .
   .    .         .      .
   .    .         .      .
   
## [1] "unique names 48"
 </pre>
</div>
```


**Changes to data frame properties**

* The *validDF* before unifying names was 15283744 Bytes (~15 MB) of memory and had 254633 rows by 7 columns.
* After adding the new fields and dropping six of the existing fields, the *analysisDF* date frame size was 7133864 Bytes (~7MB) and dimensions of 254633 rows by 3 columns.
* The transformation reduces the data frame size by roughly 8 MB.
* There were 48 distinct event names.


<hr style="background : #6B4DA4; height : 15px"/>


### Transformation 7: Group the data by EVTYPE

**Goal**

The goal of Transformation 7 is to group the data based on the NWS weather event names.

**Why?**

This project is about answering two questions:

1. **Across the United States, which types of events are most harmful with respect to population health?**
2. **Across the United States, which types of events have the greatest economic consequences?**

These questions require answer related to events and no specific data points. For example, the weather event **Avalanche** had 269 data points in the storm data file. To answer the question "...which types of events are most harmful" the analysis has to sum the *CASUALTIES* and *ECONOMIC* columns associated with this event. Counting the values manually came up with 395 casualties and about $3.7 million economic damages. To anwer the question, the analysis repeat the **Avalanche** analysis for every event type.


**How?**

The *analysisDF* is grouped by *EVTYPE* by event type, then piped to summarize_at(c("CASUALTIES", "ECONOMIC"), sum). This function will create the *CASUALTIES* and *ECONOMIIC* sums for each EVTYPE. After the grouping and summing is complete, the data frame is ordered by *EVTYPE*. The result is stored in the *analysisTable* data frame.

**Consequences**

```{=html}
<strong>Listing 7: </strong>.

<div style="font-size : 14; font-weight: bold;">
<pre>
 5240 bytes
 [1] 46  3
 # A tibble: 46 × 3
    EVTYPE                CASUALTIES    ECONOMIC
    <chr>                      <dbl>     <dbl>
  1 Astronomical Low Tide          0     0.32 
  2 Avalanche                    395     3.72 
  3 Blizzard                     959   777.   
  4 Coastal Flood                 15   408.   
  5 Cold/Wind Chill              228   100.   
  6 Debris Flow                   99   347.   
  7 Dense Fog                   1156    22.8  
  8 Dense Smoke                    0     0.1  
  9 Drought                        4 13519.   
 10 Dust Devil                    45     0.719
         .                        .      .
         .                        .      .
         .                        .      .
         
</pre>
</div>
```


**Changes to data frame properties**

* The *analysisDF* before grouping required 7133864 Bytes (~15 MB) of memory and had 254633 rows by 3 columns.
* After  grouping, the *analysisTable* date frame size required 5240 bytes and dimensions of 48 rows by 3 columns.
* The transformation reduces the data frame size by roughly 8 MB.
* There were 48 distinct event names.

<hr style="background : #1B004D; height : 15px"/>


### Transformation 8: Creating the "Damage Tables"

**Goal**

The goal of Transformation 8 is creating two tables from *analysisTable* and order each by *CASUALTIES* or *ECONOMIIC* fields.

**Why?**

The goal of the project is to find the worst events in terms of casualties and economics. However, the *analysisTable* can be ordered by *CASUALTIES* or *ECONOMIIC* but not both. By creating two copies of *analysisTable*, the Transformation and order one by *CASUALTIES* and the other by *ECONOMIC*.

With these tables, the project has enough information to answer the required questions.

An additional pair of fields are added to both tables, *PERCENT* and *ACC_PERCENT*, which could assist emergency planners. The *PERCENT* field is the *CASUALTIES*/*ECONOMIC* damage divided by the total *CASUALTIES*/*ECONOMIC* damage and multiplied by 100. This value is percent of damages caused by a given event.

The *ACC_PERCENT* is the sum of the first <em>n</em> events percentages. Since the data frame is ordered from most damaging to least damaging, the accumulated percentage is the amount of damage the worst n events are responsible for inflicting. 

For example, if the user wants to know which events are responsible for at least 90% of the *CASUALTIES* related costs, they can use the *CASUALTIES* ordered table in  the **Results** section. Looking at the **ACC_PERCENT** column, the user will find "Wildfire" at 90.8%. This means the weather events, **Tornado**, **Excessive Heat**, **Thunderstorm Wind**, **Flood**, **Lightning**, **Flash Flood**, **Ice Storm**, **High Wind**, and **Wildfire** account for 90% of the damages.

**How?**

To find the worst damages in term of casualties and economic losses, the *analysisTable* was copied into two data frames. The first was ordered by *CASUALTIES*, and the other by *ECONOMIC*. The *PERCENT* and *ACC_PERCENT* were calculated the added to each table. Both data frames are stored in a *damageTables* list. This is the final analysis product.

**Consequences**


```{=html}
<strong>Listing 8: </strong>.

<div style="font-size : 14; font-weight: bold;">
<pre>
## 6448 bytes
## [1] 48  5
## [[1]]
## # A tibble: 48 × 5
##    EVTYPE            CASUALTIES ECONOMIC PERCENT ACC_PERCENT
##                                
##  1 Tornado            96997   52057.   62.3         62.3
##  2 Excessive Heat     12363     525.    7.94        70.2
##  3 Thunderstorm Wind  10153   10939.    6.52        76.8
##  4 Flood               7280   28498.    4.68        81.4
##  5 Lightning           6049     951.    3.89        85.3
##  6 Flash Flood         2944   17519.    1.89        87.2
##  7 Ice Storm           2064    3967.    1.33        88.6
##  8 High Wind           1848    5388.    1.19        89.7
##  9 Wildfire            1698    6360.    1.09        90.8
## 10 Winter Storm        1584    1790.    1.02        91.8
    .       .               .       .       .           .
    .       .               .       .       .           .
    .       .               .       .       .           .

</pre>
<pre>
## 6448 bytes
## [1] 48  5
## [[1]]
## # A tibble: 48 × 5
##    EVTYPE            HEALTH ECONOMIC PERCENT ACC_PERCENT
##    <chr>              <dbl>    <dbl>   <dbl>       <dbl>
##  1 Tornado            96997   52057.   62.3         62.3
##  2 Excessive Heat     12363     525.    7.94        70.2
##  3 Thunderstorm Wind  10153   10939.    6.52        76.8
##  4 Flood               7280   28498.    4.68        81.4
##  5 Lightning           6049     951.    3.89        85.3
##  6 Flash Flood         2944   17519.    1.89        87.2
##  7 Ice Storm           2064    3967.    1.33        88.6
##  8 High Wind           1848    5388.    1.19        89.7
##  9 Wildfire            1698    6360.    1.09        90.8
## 10 Winter Storm        1584    1790.    1.02        91.8
    .       .               .       .       .           .
    .       .               .       .       .           .
    .       .               .       .       .           .
  
</pre>
</div>
```


**Changes to data frame properties**

* The *analysisTable* before creating the damage tables, the data frame required 5240 Bytes of memory and had 48 rows by 3 columns.
* After creating the damage tables, the *damageTables* date frame size required 6448 bytes and increased by 5 columns.
* There were 48 distinct event names.


```{=html}
</div>   <!-- Base page -->

<div style="color: black;">

```

## Processing Code

### Required Libraries 

```{r libraries}
# Required Libraries ======================================================
# This code block takes the "worstHEALTH" and the "worstLosses" tables from
# the "resultTables" an converts them to knitr:Kable tables.
# ==============================================================================
# knitr      -- The stringr library has several string manipulation functions,
#               the function that converts strings to a title
#               format. The format ensures the first letter of each word in a
#               string is converted to an upper case letter.
#
#               It is used in the Setup Phase: Program Constants section.
library(knitr)

# stringr    -- The stringr library has several string manipulation functions,
#               the str_to_title function that converts strings to a title
#               format. The format ensures the first letter of each word in a
#               string is converted to an upper case letter.
#
#               It is used in the Setup Phase: Program Constants section.
library(stringr)

# dplyr      -- The dplyr library has several functions related to data
#               wrangling,and the %>% operator. These functions are used
#               throughout the code.
library(dplyr)

# rlist      -- The rlist library has several functions to make list
#               manipulation easier. The list.append function is used through
#               the code.
library(rlist)

# kableExtra -- The kableExtra library adds to the functionality of knit::kable,
#               the basic table generator in knitr. This functionality includes
#               support for fonts, colors, table styles, and so on.
#               The knitr::kable and the kableExtra functions are used in the
#               Execute Phase to prepare the data for display.
#
#               Development Note: This should bem oved inside the Analysis
#               Phase: Construct Analysis Tables in the future.
library(kableExtra)

# ggplot2    -- all of the plots made by StormCloud are made using gplot.
#               The plot code is used in the Make Bar Images and Make Human vs.
#               Economic Image.
#
library(ggplot2)

# ggrepel    -- ggrepel is used as part of the Make Human vs. Economic Image. It
#               helps to separate point labels on the plot.
#               This code is used in the Make Human vs. Economic Image.
library(ggrepel)

# cowplot    -- cowplot to make a create a multiple plot to allow the results of
#               more than one jurisdiction to be display in plot. Since the
#               example in this demonstration includes only one jurisdiction,
#               cowplot is not required. However, StormCloud supports multiple
#               jurisdictions so it is included in the code.
#               The cowplot code is used in the Make Bar Images and Make Human
#               vs. Economic Image.
library(cowplot)

```

### "Constants"

```{r constants}
# Strictly speaking, R does not support constants, to accomodate something like 
# constants, the project uses global variables. These variables have names with
# capital letters only to distinguish them from regular variables. Once a value
# is assigned to a constant, the value must not be changed.

# The URL and DATAFILE are assigned here to avoid searching for a place to find 
# them
URL      =
  "https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2FStormData.csv.bz2"
DATAFILE = "storm.csv.bz2"


# General indexing. Rather than using numbers to identify list/data frame 
# indices, these numbers are assigned to constants with meaningfull names.
# The health index is 1 and the economic index is 2.
HEALTH_IDX     = 1
ECONOMIC_IDX   = 2

# The barplots and tables are generated in a for loop, so various names, like 
# the title, and the selection statements are set up as arrays.

# Barplots
BAR_NAMES   = c("Health", "Economic")
BAR_SELECT  = c("c('EVTYPE', 'CASUALTIES')",
                  "c('EVTYPE', 'ECONOMIC')")
BAR_REORDER = c("reorder(EVTYPE, -CASUALTIES)",
                   "reorder(EVTYPE, -ECONOMIC)")
BAR_FIELD   = c("CASUALTIES", "ECONOMIC")


# Kable tables
TABLE_FIELDS <-  c("c('EVTYPE', 'CASUALTIES', 'PERCENT', 'ACC_PERCENT')",
                  "c('EVTYPE', 'ECONOMIC', 'PERCENT', 'ACC_PERCENT')")
TABLE_LABELS <- list(
    c("Event Type", "Casualties", "Percent of Total", "Accumulated Percent"),
    c("Event Type", "Economic Losses (in millions)", "Percent of Total", 
      "Accumulated Percent"))


# These are used to print or not print the results of each transformation and to
# to select different processing paths to focus on specific details of a
# transformation. 
VERBOSE                   = TRUE    # list results of each transformation
ALL_DATA                  = FALSE    # include all data points

CONTRIBUTING_EVENTS       = TRUE    # include contributing events only
CLEAR_EVENTS              = TRUE    # includes all cleared events only
FIX_EVENTS                = TRUE    # excludes weird names    
UNIFIED_EVENTS            = TRUE    # include all un-unified events

```

### Unify Names

```{r Unify Names}
# UnifyNames ===================================================================
# 1) based on an extensive study of mapping the data collector event names to 
#    the NWS event names;
# 2) the mappings were turned in to regular expressions and included in a gsub
#    function
# ==============================================================================

UnifyNames <- function(sourceDF) {
  
  sourceDF$EVTYPE <-
    gsub("^ice storm$", "Ice Storm",
    gsub("^lake.effect snow$", "Lake-Effect Snow",
    gsub("^(lakeshore flood|lake flood)$", "Lakeshore Flood",
    gsub("^tsunami$", "Tsunami",
    gsub("^tropical depression$", "Tropical Depression",
    gsub("^tropical storm.*$", "Tropical Storm",
    gsub("^marine hail$", "Marine Hail",
    gsub("^marine high wind$", "Marine High Wind",
    gsub("^marine strong wind$", "Marine Strong Wind",
    gsub("^marine thunderstorm wind$", "Marine Thunderstorm Wind",
    gsub("^marine tstm wind$", "Marine Thunderstorm Wind",
    gsub("^storm force winds$", "Marine Strong Wind",
    gsub("^astronomical high tide$", "Coastal Flood",
    sourceDF$EVTYPE)))))))))))))

  
  sourceDF$EVTYPE <-
    gsub("^fog and cold temperatures$", "Freezing Fog",
    gsub("^freezing fog$", "Freezing Fog",
    gsub("^small hail$", "Hail",
    gsub("^gradient wind$", "Rip Current",
    sourceDF$EVTYPE))))

  sourceDF$EVTYPE <-
    gsub("^(high|heavy|rough).+seas.*$", "Marine Strong Wind",
    gsub("^(high|heavy).+swells.*$", "Marine High Wind",
    gsub("^(typhoon|hurricane.*)$", "Hurricane/Typhoon",
    gsub("^drowning$", "Rip Current",
    sourceDF$EVTYPE))))

  sourceDF$EVTYPE <-
    gsub("^.*coastal.*$", "Coastal Flood",
    gsub("^.*erosion.*$", "High Surf",
    gsub("^.*tidal.*$", "Coastal Flood",
    gsub("^storm surge.*$", "Storm Tide",
    gsub("^high.+(tides|waves).*$", "Storm Tide",
    gsub("^rogue.+$", "Storm Tide",
    sourceDF$EVTYPE))))))

  sourceDF$EVTYPE <-
    gsub("^(dam break|ice floes|ice jam( flood.+|))$", "Flash Flood",
    gsub("^.+small stream urban$", "Flash Flood",
    gsub("^urban.+(small|stream).*$", "Flash Flood",
    gsub("^(small|minor).+flood.*$", "Flash Flood",
    gsub("^flood.+flash.*$", "Flash Flood",
    gsub("^flash.*$", "Flash Flood",
    sourceDF$EVTYPE))))))

  sourceDF$EVTYPE <-
    gsub("^.*freezing (drizzle|rain|spray).*$", "Winter Weather",
    sourceDF$EVTYPE)

  # # must come after marine
  sourceDF$EVTYPE <-
    gsub("^hail.*$", "Hail",
    gsub("^thunderstorm.+hail$", "Hail",
    gsub("^.*tstm.+hail$", "Hail",
    gsub("^(wind|gusty).+hail$", "Hail",
    sourceDF$EVTYPE))))

  sourceDF$EVTYPE <-
    gsub("^(wind|non|gusty).+wind.*$", "High Wind",
    gsub("^(strong|gusty).*$", "Strong Wind",
    gsub("^(rain.+wind|wind.+rain)$", "High Wind",
    gsub("^wind.*$", "High Wind",
    gsub("^rip current.*$", "Rip Current",
    sourceDF$EVTYPE)))))

  sourceDF$EVTYPE <-
    gsub("^(wind|gusty).+rain$", "Heavy Rain",
    gsub("^(unseasonal|hvy|high.+heavy).+rain.*$", "Heavy Rain",
    gsub("^rain(.*|fall)$", "Heavy Rain",
    gsub("^heavy (shower|precipitation)$", "Heavy Rain",
    gsub("^heavy.(rain|rains)$", "Heavy Rain",
    gsub("^heavy rain/severe weather$", "Heavy Rain",
    gsub("^(torrential|record|excessive) rainfall$", "Heavy Rain",
    sourceDF$EVTYPE)))))))

  sourceDF$EVTYPE <-
    gsub("^heavy rain/lightning", "Lightning",
    gsub("^thunderstorm.+lightning", "Lightning",
    gsub("^tstm.+lightning", "Lightning",
    gsub("^ligntning$", "Lightning",
    gsub("^lighting$", "Lightning",
    gsub("^ligntning+rain$", "Heavy Rain",
    gsub("^lightning.*$", "Lightning",
    sourceDF$EVTYPE)))))))

  sourceDF$EVTYPE <-
    gsub("^thunderstorm.+flood($|ing$)", "Flood",
    gsub("^high.+water$", "Flood",
    gsub("^(flood|river|rural|major|break).+$", "Flood",
    gsub("^urban.+flood.*$", "Flood",
    gsub("^ice jam flooding$", "Flood",
    gsub("^rapidly rising water$", "Flood",
    gsub("^flood$", "Flood",
    gsub("^heavy rain(s/flooding| and flood)$", "Flood",
    gsub("^heavy snow/high winds & flood$", "Flood",
    sourceDF$EVTYPE)))))))))

  sourceDF$EVTYPE <-
    gsub("^thunder.+$", "Thunderstorm Wind",
    gsub("^tstm.+$", "Thunderstorm Wind",
    gsub("^.+burst.*$", "Thunderstorm Wind",
    gsub("^severe thunder.+$", "Thunderstorm Wind",
    gsub("^severe turb.+$", "Thunderstorm Wind",
    gsub("^whirlwind$", "Thunderstorm Wind",
    gsub("^(thude|thune|tund|thundeer).+$", "Thunderstorm Wind",
    sourceDF$EVTYPE)))))))

  sourceDF$EVTYPE <-
    gsub("^(cold air torn|torn).+$", "Tornado",
    gsub("^(gustnado|landspout)$", "Tornado",
    sourceDF$EVTYPE))

  sourceDF$EVTYPE <-
    gsub("^.*heavy snow$", "Heavy Snow",
    gsub("^(excessive|high|heavy).+snow$", "Heavy Snow",
    gsub("^record snow$", "Winter Weather",
    sourceDF$EVTYPE)))

  sourceDF$EVTYPE <-
    gsub("^extreme.+chill$|^(extended|extreme|record) cold$", "Extreme Cold/Wind Chill",
    gsub("^hypo.+$", "Extreme Cold/Wind Chill",
    sourceDF$EVTYPE))

  sourceDF$EVTYPE <-
    gsub("^high.+blizzard.*$", "Blizzard",
    gsub("^.*blowing snow$", "Blizzard",
    gsub("^.*blizzard.*$", "Blizzard",
    gsub("^high.+wind.*$", "High Wind",
    gsub("^snow/high winds$", "Blizzard",
    sourceDF$EVTYPE)))))

  sourceDF$EVTYPE <-
    gsub("^heavy.+ice$", "Winter Storm",
    gsub("^heavy.+storm$", "Winter Storm",
    gsub("^heavy.+winds$", "Winter Storm",
    gsub("^heavy.+snow.*$", "Winter Storm",
    gsub("^winter.+storm$", "Winter Storm",
    gsub("^.*winter storm.+$", "Winter Storm",
    sourceDF$EVTYPE))))))

  sourceDF$EVTYPE <-
    gsub("^.*sl(ide|ump).*$", "Debris Flow",
    gsub("^(snow|sleet|glaze).+ice storm$", "Winter Weather",
    gsub("^glaze.*$", "Winter Weather",
    sourceDF$EVTYPE)))


  sourceDF$EVTYPE <-
    gsub("^cool and wet$", "Winter Weather",
    gsub("^(late|light).+snow.*$", "Winter Weather",
    gsub("^.*winter storm.+$", "Winter Storm",
    gsub("^(rain.snow|snow.rain)$", "Winter Weather",
    gsub("^falling snow/ice$", "Winter Weather",
    gsub("^wint.+$", "Winter Weather",
    sourceDF$EVTYPE))))))

  sourceDF$EVTYPE <-
    gsub("^.*drought.*$", "Drought",
    gsub("^.*heat.*$", "Excessive Heat",
    gsub("^hyper.+$", "Excessive Heat",
    gsub("^.*warm.*$", "Heat",
    sourceDF$EVTYPE))))

  sourceDF$EVTYPE <-
    gsub("^dust storm.*$", "Dust Storm",
    gsub("^blowing dust$", "Dust Storm",
    gsub("^.*waterspout.*$", "Waterspout",
    gsub("^.*dust devil.*$", "Dust Devil",
    sourceDF$EVTYPE))))

  sourceDF$EVTYPE <-
    gsub("^.*(frost|freeze).*$", "Frost/Freeze",
    sourceDF$EVTYPE)

  sourceDF$EVTYPE <-
    gsub("^ic(e|y).*$", "Winter Weather",
    gsub("^.*mix.*$", "Winter Weather",
    sourceDF$EVTYPE))

sourceDF$EVTYPE <-
  gsub("^snow.*$", "Winter Weather",
  gsub("^sleet$", "Winter Weather",
  gsub("^.*cold.*$", "Cold/Wind Chill",
  gsub("^low.*$", "Cold/Wind Chill",
  sourceDF$EVTYPE))))

sourceDF$EVTYPE <-
  gsub("^cold.*(.*|temperature|wave|winds|wind chill)$", "Cold/Wind Chill",
  gsub("^high.+cold$", "Cold/Wind Chill",
  gsub("^.*cold.*$", "Cold/Wind Chill",
  gsub("^low.*$", "Cold/Wind Chill",
  sourceDF$EVTYPE))))

  sourceDF$EVTYPE <-
    gsub("^(high|heavy|rough|hazardous).+surf.*$", "High Surf",
    gsub("^avalanc.*$", "Avalanche",
    gsub("^seiche$", "Seiche",
    gsub("^volcanic ash$", "Volcanic Ash",
    gsub("^astronomical low tide$", "Astronomical Low Tide",
    gsub("^black ice$", "Winter Weather",
    gsub("^excessive wetness$", "Winter Weather",
    gsub("^rainstorm$", "Heavy Rain",
    gsub("^heavy precipitation$", "Heavy Rain",
    gsub("^(dense|.*)fog$", "Dense Fog",
    gsub("^falling snow/ice$", "Winter Weather",
    sourceDF$EVTYPE)))))))))))

  sourceDF$EVTYPE <-
    gsub("^.*fire.*$", "Wildfire",
    gsub("^.*funnel.*$", "Funnel Cloud",
    gsub("^.*smoke$", "Dense Smoke",
    sourceDF$EVTYPE)))
  if (VERBOSE) {
    print(paste0("sourceDF ", dim(sourceDF)))
    print(head(sourceDF))
  }

  return (sourceDF)
}

```

```{r processing}

  if (!file.exists(DATAFILE)) {
    retrieve = download.file(URL, DATAFILE, mode = "wb")

    if (is.null(retrieve)) {
      print("ERROR: could not access ", url)
      stop()
    }
  }

```

### Transformation 0:  No transformations

```{r}
# ==============================================================================
# This code is used to measure the size of a data.frame with the entire contents
# of the data file. The program will terminate at the end of the if statement
# ==============================================================================

# if VERBOSE and ALL_DATA are TRUE, load the whole data file, print the state
# information and exit the RMarkdown program.
if (VERBOSE & ALL_DATA) {
  sourceDF <- read.table(DATAFILE, sep = ",", header = TRUE)

  print("Transformation 0")
  print(paste0("Number of unique event names         ", 
               length(unique(sourceDF$EVTYPE))))
  print(paste0("The data frame memory requirement is ", object.size(sourceDF)))
  print(paste0("The data frame dimensions are        ", dim(sourceDF)))
  print(head(sourceDF, n = 10))

  knitr::knit_exit()
}

```

### Transformation 1: Reading the data file

```{r transformations}
# ==============================================================================
# This transformation reads specific fields from the data file.
# EVTYPE, FATALITIES, INJURIES, PROPDMG, PROPDMGEXP, CROPDMG, and CROPDMGEXP.
# ==============================================================================

sourceDF <- read.table(DATAFILE, stringsAsFactors = FALSE, sep = ",",
                       colClasses = c(rep("NULL",7), NA, rep("NULL",14),
                                      rep(NA, 6), rep("NULL",9)), header = TRUE)

# if VERBOSE is TRUE  print the state of the sourceDF
if (VERBOSE) {
  print("Transformation 1")
  print(paste0("Number of unique event names         ", 
               length(unique(sourceDF$EVTYPE))))
  print(paste0("The data frame memory requirement is ", object.size(sourceDF)))
  print(paste0("The data frame dimensions are        ", dim(sourceDF)))
  print(head(sourceDF, n = 10))
}

```

### Transformation 2: Removing non-contributing data points

```{r}
# ==============================================================================
# This transformation removes any data point from the data frame whose numeric
# are all zero. These will not contribute to the results.
# ==============================================================================
# if VERBOSE is TRUE print the state of the sourceDF before Transformation 2
if (VERBOSE) {
  print("Before Transformation 2")
  # Hail non-contributing value, multiple instances of "Hail"
  print(sourceDF[82,])     
  # '?' invalid name, contributing value
  print(sourceDF[246124,])   
  # "Summary: Nov. 16" invalid name, non-contributing value
  print(sourceDF[271399,]) 
  
}

sourceDF <- sourceDF[sourceDF$FATALITIES != 0 | sourceDF$INJURIES != 0 |
                     sourceDF$PROPDMG != 0 | sourceDF$CROPDMG != 0, ]

# if VERBOSE is TRUE print the state of the sourceDF
if (VERBOSE) {
  print("Transformation 2")
  print(paste0("Number of unique event names         ", 
               length(unique(sourceDF$EVTYPE))))
  print(paste0("The data frame memory requirement is ", object.size(sourceDF)))
  print(paste0("The data frame dimensions are        ", dim(sourceDF)))
  print(head(sourceDF, n = 10))
  
  if ('HAIL' %in% sourceDF$EVTYPE){
    print("CORRECT: HAIL found")
  } else {
    print("WRONG: HAIL not found")
  }
  
  if ('?' %in% sourceDF$EVTYPE){
    print("CORRECT: ? found")
  } else {
    print("WRONG: ? not found")
  }
  
  if ('Summary: Nov. 16' %in% sourceDF$EVTYPE){
    print("WRONG: Summary: Nov. 16 found")
  } else {
    print("CORRECT: Summary: Nov. 16 not found")
  }
  
}

```

### Transformation 3: Clear white spaces from strings

```{r}
# ==============================================================================
# This transformation trims the white space from all string data then converts
# the all characters to lower case.
# ==============================================================================
if (VERBOSE) {
  if (' FLASH FLOOD' %in% sourceDF$EVTYPE){
    print(" FLASH FLOOD found")
  } else {
    print(" FLASH FLOOD not found")
  }
}
sourceDF$EVTYPE     <- trimws(sourceDF$EVTYPE, which = c("both"))
sourceDF$PROPDMGEXP <- trimws(sourceDF$PROPDMGEXP, which = c("both"))
sourceDF$CROPDMGEXP <- trimws(sourceDF$CROPDMGEXP, which = c("both"))
sourceDF$EVTYPE     <- tolower(sourceDF$EVTYPE)
sourceDF$PROPDMGEXP <- tolower(sourceDF$PROPDMGEXP)
sourceDF$CROPDMGEXP <- tolower(sourceDF$CROPDMGEXP)

# if VERBOSE is TRUE print the state of the sourceDF
if (VERBOSE) {
  print("Transformation 3")
  print(paste0("Number of unique event names         ", 
               length(unique(sourceDF$EVTYPE))))
  print(paste0("The data frame memory requirement is ", object.size(sourceDF)))
  print(paste0("The data frame dimensions are        ", dim(sourceDF)))
  print(head(sourceDF, n = 10))
  
  if (' FLASH FLOOD' %in% sourceDF$EVTYPE){
    print(" FLASH FLOOD found")
  } else {
    print(" FLASH FLOOD not found")
  }
  if ('FLASH FLOOD' %in% sourceDF$EVTYPE){
    print("FLASH FLOOD found")
  } else {
    print("FLASH FLOOD not found")
  }
  if (' flash flood' %in% sourceDF$EVTYPE){
    print(" flash flood found")
  } else {
    print(" flash flood not found")
  }
  if ('flash flood' %in% sourceDF$EVTYPE){
    print("flash flood found")
  } else {
    print("flash flood not found")
  }
}

```

### Transformation 4: Fixing invalid names

```{r}
# ==============================================================================
# This transformation converts event names, with no correspondence to the NWS
# names, to "Other".
# ==============================================================================

if (VERBOSE) {
  print(sourceDF[sourceDF$EVTYPE == "?", ])
  print(which(rownames(sourceDF) == 246124))
}

sourceDF$EVTYPE <-
  gsub("\\?", "Other",
  gsub("^high$", "Other",
  gsub("^marine accident$", "Other",
  gsub("^marine mishap$", "Other",
  gsub("^other$", "Other",
  gsub("^apache county$", "Other",
  sourceDF$EVTYPE))))))

if (VERBOSE) {
  print("Transformation 4")
  print(paste0("Number of unique event names         ", 
               length(unique(sourceDF$EVTYPE))))
  print(paste0("The data frame memory requirement is ", object.size(sourceDF)))
  print(paste0("The data frame dimensions are        ", dim(sourceDF)))
  print(head(sourceDF, n = 10))
  print(paste0("The output of id 246124 after the transformation", 
               sourceDF[52498, ]))
}

```


### Transformation 5: Unify the event names

```{r}
# ==============================================================================
# This transformation calls the UnifyNames function. The function will check for
# for matches to data collector names and re-write them is the corresponding 
# NWS name.
# ==============================================================================
validDF    <- UnifyNames(sourceDF)


# if VERBOSE is TRUE  print the state of the validDF
if (VERBOSE) {
  print("Transformation 5")
  print(paste0("Number of unique event names         ", 
               length(unique(sourceDF$EVTYPE))))
  print(paste0("The data frame memory requirement is ", object.size(validDF)))
  print(paste0("The data frame dimensions are ", dim(validDF)))
  print(head(sourceDF, n = 10))
}

```

### Transformation 6: Set up the analysis data frame

```{r}

analysisDF <- validDF %>% ungroup(.) %>%
  mutate (PROPDMGEXP = ifelse(PROPDMGEXP == 'k', 1000.,
                              ifelse(PROPDMGEXP == 'm', 1000000., 1.)),
          CROPDMGEXP = ifelse(CROPDMGEXP == 'k', 1000.,
                              ifelse(CROPDMGEXP == 'm', 1000000., 1.) ),
          PROPDMG    = PROPDMG * PROPDMGEXP,
          CROPDMG    = CROPDMG * CROPDMGEXP,
          CASUALTIES     = FATALITIES + INJURIES,
          ECONOMIC   = (PROPDMG + CROPDMG)/1000000.0
          ) %>%
  select(EVTYPE, CASUALTIES, ECONOMIC)

colnames(analysisDF) <- c('EVTYPE', 'CASUALTIES', 'ECONOMIC')

# if VERBOSE is TRUE print the state of the analysisDF
if (VERBOSE) {
  print("Transformation 6")
  print(paste0("Number of unique event names         ", 
               length(unique(sourceDF$EVTYPE))))
  print(paste0("The data frame memory requirement is ", 
               object.size(analysisDF)))
  print(paste0("The data frame dimensions are ", dim(analysisDF)))
  print(head(sourceDF, n = 10))
}


```

### Transformation 7: Group the data by EVTYPE

```{r}

analysisTable <- analysisDF %>% group_by(EVTYPE) %>% 
  summarise_at(c("CASUALTIES", "ECONOMIC"), sum) %>% 
  arrange(.$EVTYPE, .by_group = TRUE)

# if VERBOSE is TRUE print the state of the analysisTable
if (VERBOSE) {
  print("Transformation 7")
  tempDF <- data.frame(analysisTable)
  print(paste0("Number of unique event names ",
               length(unique(tempDF$EVTYPE))))
  print(object.size(tempDF))
  print(dim(tempDF))
  print(head(sourceDF, n = 10))
}

```

### Transformation 8:  Creating the "Damage Tables"

```{r}

damageTables = list()

DAMAGE_ORDERING = c("desc(.$CASUALTIES)", "desc(.$ECONOMIC)")

for (damageType in HEALTH_IDX:ECONOMIC_IDX) {
  table <- analysisTable %>%
    arrange(eval(parse(text=DAMAGE_ORDERING[damageType])), .by_group = TRUE)
  totalValue <- sum(table[, damageType + 1])

  accumulator     <- 0
  percentList     <- list()
  accumulatorList <- list()

  for (i in 1:length(table$EVTYPE)) {
    percent <- table[i, damageType + 1]*100/totalValue
    accumulator <- accumulator + percent
    percentList <- append(percentList, percent)
    accumulatorList <- append(accumulatorList, accumulator)
  }
   table$PERCENT <- as.numeric(unlist(percentList))
   table$ACC_PERCENT <- as.numeric(unlist(accumulatorList))

  if (damageType == HEALTH_IDX) {
     worstHEALTH <- table
  } else if (damageType == ECONOMIC_IDX) {
     worstLosses <- table
  }

  damageTables <- list.append(damageTables, table)
  
  # if VERBOSE is TRUE print the state of damageTables
  if (VERBOSE) {
    print("Transformation 8")
    for (damageType in HEALTH_IDX:ECONOMIC_IDX) {
      print(paste0("Damage table ", damageType))
      print(paste0("Number of unique event names ",
                   length(unique(tempDF$EVTYPE))))
      print(object.size(damageTables[damageType]))
      print(dim(damageTables[damageType]))
      print(head(sourceDF, n = 10))
    }
  }
} # end of for loop
```

## Output

```{r}
barPlot <- function (damageTable, damageType)
{
  table <- head(damageTable, n=10) %>%
  select(eval(parse(text = BAR_SELECT[[damageType]])))
  colnames(table) <- eval(parse(text = BAR_SELECT[[damageType]]))
  table$EVTYPE <- factor(table$EVTYPE, levels = table$EVTYPE)
  
  if (VERBOSE) {
    print(paste0("Bar plot data frame ", damageType))
    print(object.size(table))
    print(dim(table))
    print(table)
  }

  plt <- ggplot(table,
                aes(x = eval(parse(text=BAR_REORDER[[damageType]])),
                    y = eval(parse(text=BAR_FIELD[[damageType]])))) +
    ggtitle(paste0("Figure ", damageType,". Storm Related ",
                   str_to_title(TABLE_LABELS[[damageType]][2]))) +
    xlab("Event") +
    ylab(str_to_title(TABLE_LABELS[[damageType]][2])) +
    geom_bar(stat="identity", width=0.7, fill="steelblue") +
    theme(plot.title = element_text(face="plain", color="black", size=12),
          axis.text.x = element_text(size = 5, face="bold", angle = -10, hjust = 0, vjust = 0),
          axis.text.y = element_text(size = 5, face="bold"),
          axis.title.x = element_text(size = 8, face="bold"),
          axis.title.y = element_text(size = 8, face="bold"))
  save_plot(paste0("EVTYPE_v_HEALTH-0", damageType, ".png"), plt)
}

```

```{r}
scatterPlot <- function (damageTables, damageType)
{

  set <- c(head(damageTables[[1]]$EVTYPE, n = 10),
                head(damageTables[[2]]$EVTYPE, n = 10))
  eventSet <- unique(set)
  

  bigEvt <- analysisTable[analysisTable$EVTYPE %in% eventSet,  ]
  plotTable <- analysisTable[!(analysisTable$EVTYPE %in% eventSet),  ]
  plotTable$EVTYPE <- "z other"
  plotTable <- rbind(bigEvt, plotTable)
  

  
  if (VERBOSE) {
    print("plotTable data frame ")
    print(object.size(plotTable))
    print(dim(plotTable))
    # print(plotTable, n = 48)
  }


  plt <- ggplot(plotTable, aes(x = CASUALTIES, y = ECONOMIC)) +
    ggtitle("Figure 3. United States Public Health vs. Economic Losses") +
    xlab(TABLE_LABELS[[1]][2]) + ylab(TABLE_LABELS[[2]][2]) +
    theme(plot.title = element_text(face="plain", color="black", size=28),
          axis.title.x = 
            element_text(face="bold", color="black", size=14),
          axis.title.y = element_text(face="bold", color="black", size=14),
          axis.text = element_text(size = 10, face="bold"),
          panel.background = element_rect(fill = "gray60",
                                          color = "gray90",
                                          size = 0.1, 
                                          linetype = "dashed")) +
    scale_color_manual(
      values = c("#8B4513", "#D02010", "#8B4500", "darkslategray1", "snow1",
                 "ivory2", "slateblue4", "paleturquoise1", "lemonchiffon1", 
                 "#505050", "#030303", "#f03020", "snow1", "black"),
      labels = c("Drought", "Excessive Heat", "Flash Flood", "Flood", "Hail",
                 "High Wind", "Hurricane/Typhoon", "Ice Storm", "Lightning",
                 "Thunderstorm Wind", "Tornado", "Wildfire", "Winter Storm",
                 "other"),
      guide = guide_legend(override.aes = list(size = 3) ))   + 
    geom_point(data = plotTable, aes(x = CASUALTIES, y = ECONOMIC, 
                                     color = EVTYPE), size=2) +
    geom_text_repel (
      data = bigEvt,
      aes(x=CASUALTIES, y=ECONOMIC, label = EVTYPE, color = EVTYPE, fontface = "bold"),
      min.segment.length = 0.0, nudge_y = 1000.0, nudge_x = 1500.0,
      force = 100.0,
      force_pull = 30.0
    )
  
  save_plot("HEALTH_v_ECONOMIC.png", plt, ncol = 2, nrow = 2)
}

```

```{r}

getTable <- function (damageTable, damageType)
{
  damageTable <- damageTable %>%
    select(eval(parse(text = TABLE_FIELDS[[damageType]])))

  resTable <- knitr::kable(head(damageTable, n = 50), "html",
    caption = paste0("<center><strong><font size='1'>",
                     "Table ", damageType,". United States ",
                     TABLE_LABELS[[damageType]][2],
                     "</font><center></strong>"),
    digits = 3, align = "lrrr",
    col.names = c(TABLE_LABELS[[damageType]]), row.names = TRUE
    ) %>%
    kable_styling(bootstrap_options = c("striped", "hover"),
                  full_width = F,
                  position = "left",
                  font_size = 10) %>%
    column_spec(column=1, width="1cm") %>%
    column_spec(column=2, width="3cm") %>%
    column_spec(column=3, width="2cm") %>%
    column_spec(column=4, width="2cm") %>%
    kable_classic_2()

  return (resTable)

}

```



```{r images}

barPlot(damageTables[[HEALTH_IDX]], HEALTH_IDX)
barPlot(damageTables[[ECONOMIC_IDX]], ECONOMIC_IDX)
scatterPlot(damageTables)

casualtyTable <- getTable(damageTables[[HEALTH_IDX]], HEALTH_IDX)
lossesTable   <- getTable(damageTables[[ECONOMIC_IDX]], ECONOMIC_IDX)

```



<hr style="background: DarkOrchid; height: 3px"/>

# Results

This project was designed to answer the following questions: 

1. Across the United States, which types of events are most harmful with respect to population health?
2. Across the United States, which types of events have the greatest economic consequences?

The results of the analysis are stored in a list of two data frames. One data frame contains the events, number of casualties, economic losses, the percent and accumulated percent for each event types. It is also ordered by casualty from most to least. The second data frame is like the first, except the focus is on economic losses and ordered accordingly.


## Tables

Table 1 lists the contents of the casualty data frame. Using this table, an emergency planner can answer the question, "...which types of events are most harmful with respect to population health" in several ways. For example, the 10 most harmful events can be found by looking at first 10 rows of the table. They are Tornado, Excessive Heat, Thunderstorm Wind, Flood, Lightning, Flash Flood, Ice Storm, High Wind, Wildfire, and Winter Storm. If the user wants to know which events account for 90% of the casualties, they could look at Accumulated Percent column and find the first value over 90%. It turns out to be Wildfire. THe 95% worst categories end at Heavy Snow and the 99%, in row 23, is Avalanche. 

```{r, message=TRUE, echo = TRUE}
casualtyTable
```

```{=html}
<div style="font-size : 8; font-weight: normal; text-indent: 150px;">
Source ...
</div>   <!-- Base page -->
```

Table 2 lists the contents of the economic loss data frame. Using this table, an emergency planner can answer the question, "...which types of events have the greatest economic consequences" in several ways. The 10 most costly events are Tornado, Flood, Flash Flood, Hail, Hurricane/Typhoon, Drought, Thunderstorm Wind, Wildfire, High Wind, and Ice Storm. Ninety percent of the worst economic losses is the same as the ten most costly events. All of the events through Heavy Rain account for 95% of economic losses and the events up to and including Excessive Heat are responsible for 99% of economic losses.

```{r, message=TRUE, echo = TRUE}
lossesTable
```

## Graphs

Figure 1 shows the number of casualties for the ten most harmful weather events. It is the same data found in Table 1 but the plot provides a visual description of that data. A user can see the dramatic difference between the most harmful event, Tornado and the second most harmful event, Excessive Heat. The remaining events taper off slowly.

```{r, message=TRUE, echo = TRUE}
    knitr::include_graphics("EVTYPE_v_HEALTH-01.png")
```




Figure 2 displays of the ten most costly weather events. It is the same data found in Table 2 and it provides a visual description of that data. Like Figure 1, the Tornado event was the most damaging. However the difference between Tornado and the second worst event, Flood is not as dramatic. Like Figure 1, the remaining events taper off but not as slowly.

```{r, message=TRUE, echo = TRUE}
    knitr::include_graphics("EVTYPE_v_HEALTH-02.png")
```

```{r, message=TRUE, echo = TRUE}
    knitr::include_graphics("HEALTH_v_ECONOMIC.png")
```





The results for this project is presented in Tables


The United States has a variety of weather events ranging from the extreme cold and extreme heat, extreme precipitation and lack of precipitation, tornadoes, hurricanes, etc. To understand the impact of these events, the National Oceanographic and Atmospheric Administration (NOAA) collects and analyzes weather data from all over the country. The data are restricted to forty-eight "significant weather phenomena[1]" and associated data. Part of the collected information induces the number of CASUALTIES (deaths and injuries) and the amount of damage to property including crop damage.

StormCloud was produced to provide emergency services planners information regarding the damage to human life and the financial losses of specific weather events. Using this information, planners can help mitigate the damage by understanding the damages of these events. To this end, StormCloud presents presents the damages for storm damage as independent sets of data, one describing the human damage, and the other describing the financial damage.

In Table 1a, the list of weather related CASUALTIES from 1950 to approximately 2012. The numbers range from 0 \~ 97,000 deaths or injuries. From the data in Table 1a, tornadoes are the leading cause of weather related CASUALTIES in the United States with 96,907 dead or injured followed by "Excessive Heat" with \~12,363 dead or injured. Comparing the relative seriousness of weather events, tornadoes represent 62% of all CASUALTIES. In fact, 90% of all US weather related CASUALTIES happen with the eight worst weather events and 99% happen with the worst 21 events.

Table 1b is a list of weather related financial losses. Again, tornadoes are the biggest economic with approximately \$52 billion in losses from 1950 to 2012. This amounts to 27% of all weather related losses, which is significantly less proportion of CASUALTIES caused by tornadoes. The first nine events from Table 1b account for 90% of weather related financial losses compared to eight for CASUALTIES. The 99% level for financial losses happens in the first 19 events compared to 21 for CASUALTIES.

The weather events tables 1a and 1b show the number of CASUALTIES and the financial losses due to those events gives an overall picture of the damage caused by severe weather, but the dramatic differences between event types and types of damage within an event type are difficult to discern. Figure 1 shows an eight-fold difference in CASUALTIES between "Excessive Heat" and "Tornado". In contrast, Figure 2 shows a two-fold difference between in economic loss between "Flood" and "Tornado". The second event type differs between CASUALTIES and economic loss, which raises an interesting question. Since the worst events associated with casualties are different then the events associated with economic losses, how should planners adapt their emergency response to based on the resources required by these different emergencies. Figure 3 is a plot of CASUALTIES versus economic losses. As with all of the data in this study, tornadoes are far worst than any other weather event, but which event is the second worst? This is a judgment call for the planners, but StormCloud the plot in Figure 3, gives planners a tool to help assess how to distribute resources and to request resources from government agencies.

The U.S. Federal Emergency Management Agency (FEMA) places the Valuation of Statistical Life (VSL) at \$12.5 million [2] based on a U.S. Department of Transportation memo [3]. With this information, emergency planners could monetize the value of a human life. In addition to the VSL, FEMA also uses the Abbreviated Injury Scale (AIS) to monetize the damage of injuries based on their seriousness. By monetizing deaths and injuries, the CASUALTIES versus Economic Loss plot could include a line dividing the amount of given resources required by an emergency response.


<hr style="background:#36013F; height:30px"/>

# Bibliography

[1] <https://www.ncdc.noaa.gov/stormevents/>

[2] NATIONAL WEATHER SERVICE INSTRUCTION 10-1605 downloaded from <https://www.nws.noaa.gov/directives/sym/pd01016005curr.pdf> on July 8, 2023


```{=html}
</div>   <!-- Base page -->


```
