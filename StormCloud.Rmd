---
title: 'Severe Weather: Preparing for Emergency Response'
author: "Kevin Glass"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
    toc_depth: 3
    number_sections: yes
    toc_float:
      toc_collapsed: yes
    theme: united
---

```{r knitr setup}

knitr::opts_chunk$set(echo = TRUE)
options(max.print = 1000000)

```


```{=html}
<div style="font-size : 12; color: black; font-weight: normal;">  <!-- Base page -->
```

# Synopsis

This document is designed to assist emergency response organizations to prepare for severe weather events in the United States. Tornadoes in the Midwest, hurricanes in the Gulf Coast and Eastern Seaboard, severe winter storms in the Mountain West, and so on, require these organizations to deal with different relief needs in differing geographical areas. In particular, weather events can cause human HEALTH (injuries and deaths), economic losses (property or crop damage), or both. Using historical data provided by National Oceanographic and Atmospheric Agency (NOAA) Storm Events Database [a], we assessed the kinds of damages caused by each type of event. 


The document cleaned the historical data; removed data points that were either non-contributing, i.e., added no values to both HEALTH and losses; and ensured all of the event names conformed to the National Weather Service (NWS) Instruction 10-1605 [b]. 


From this, the document creates a pair of tables showing the worst ten events in terms of human casualties and economic losses. With this data document generates and displays two images visualizing from the worst ten events tables. A final image is a plot of casualties versus economic losses, which visually shows the type of resources (medical or financial) a given event would need. 

# Data Processing
```{=html}
<div style="color: green;">
```

## Data Transformations

```{=html}
</div> 
<div style="color: black;">

```

The analysis is designed to answer two questions:

1. **Across the United States, which types of events are most harmful with respect to population health?**
2. **Across the United States, which types of events have the greatest economic consequences?**

To answer these questions, select data fields must be transformed from its raw form to a form with the data grouped by the event type, *EVTYPE*, with data describing the effect of the event on public health and economic losses. The raw data is not structured in a way that would allow this analysis. 

To get the data into an appropriate structure requires several transformations. Some of these transformations are complex and require detailed explanation. This section will describe why a change is needed, how it is done, and the consequences for the data structures.

### Glossary
Before describing the transformation, the reader needs some introductory nomenclature:

<div style="color: red;">

The *FATALITIES*, *INJURIES*, *PROPDMG*, *PROPDMGEXP*, *CROPDMG*, and *CROPDMGEXP* fields are required to produce numerical results for each *EVTYPE*. Though *PROPDMGEXP*, and *CROPDMGEXP* are string data, they will be converted to numeric data in the  transformations.

```{=html}
</div> 
<div style="color: black;">

```

**initial data fields** are *EVTYPE*, *FATALITIES*, *INJURIES*, *PROPDMG*, *PROPDMGEXP*, *CROPDMG*, and *CROPDMGEXP*. These are the fields used to read the source data file.

**categorical dependent field**  *EVTYPE*.

**numeric fields**  *FATALITIES*, *INJURIES*, *PROPDMG*, and *CROPDMG*

**exponent fields** are *PROPDMGEXP*, and *CROPDMGEXP*. The values are stored as character type and must be converted to numeric types before performing any computation. 

**damage types** are *HEALTH*  and *ECONOMIC*. For this assignment, *HEALTH* is the sum of *FATALITIES* and *INJURIES*. *ECONOMIC* is the sum of *PROPDMG* * *PROPDMGEXP*, and *CROPDMG* * *CROPDMGEXP*.

**unifying names** is the process ensuring all names used by the data collectors are replaced with the appropriate NWS type names.

<hr style="background : #6D0500; height : 15px"/>


### Transformation 0: No transformations

**Goal**

To provide a baseline for comparing the effect of each transformation on the memory size required to store the resulting data frame (or tibble) and its dimensions.

**Why?**

One part of understanding the impact of each transformation is understanding how it impacts memory use and how it changes the structure of the data frame. Since the first transformation happens when the data is read, so assessing the impact requires knowing the impact of the transforming read on the data before it is transformed.


**How?**

A block of code 

Two "constants" are set before the code is evaluated. The first *VERBOSE* is used to print output when the document user wants to verify aspects of the analysis. The second *ALL_DATA*, ensures the code reads the entire data file. The later is only need to check the full file data and should not be used for analysis purposes.

**Consequences**

```{=html}
<div style="font-size : 14;">

<strong>Listing 0:</strong> The memory size required to store the data is 50601984, the dimesions of sourceDF are 902297 by 7 and the head of the data frame is shown below.

<pre>
## 494295216 bytes
## [1] 902297     37
##   STATE__           BGN_DATE BGN_TIME TIME_ZONE COUNTY COUNTYNAME STATE  EVTYPE
## 1       1  4/18/1950 0:00:00     0130       CST     97     MOBILE    AL TORNADO
## 2       1  4/18/1950 0:00:00     0145       CST      3    BALDWIN    AL TORNADO
## 3       1  2/20/1951 0:00:00     1600       CST     57    FAYETTE    AL TORNADO
## 4       1   6/8/1951 0:00:00     0900       CST     89    MADISON    AL TORNADO
## 5       1 11/15/1951 0:00:00     1500       CST     43    CULLMAN    AL TORNADO
## 6       1 11/15/1951 0:00:00     2000       CST     77 LAUDERDALE    AL TORNADO
   .              .                   .         .       .      .        .     . 
   .              .                   .         .       .      .        .     . 
   .              .                   .         .       .      .        .     . 
   
##   BGN_RANGE BGN_AZI BGN_LOCATI END_DATE END_TIME COUNTY_END COUNTYENDN
## 1         0    .         .         .       .      .       0         NA
## 2         0    .         .         .       .      .       0         NA
## 3         0    .         .         .       .      .       0         NA
## 4         0    .         .         .       .      .       0         NA
## 5         0    .         .         .       .      .       0         NA
## 6         0    .         .         .       .      .       0         NA
   .         .              .         .       .      .      .           . 
   .         .              .         .       .      .      .           . 
   .         .              .         .       .      .      .           . 
   
##   END_RANGE END_AZI END_LOCATI LENGTH WIDTH F MAG FATALITIES INJURIES PROPDMG
## 1         0    .         .       14.0   100 3   0          0       15    25.0
## 2         0    .         .        2.0   150 2   0          0        0     2.5
## 3         0    .         .        0.1   123 2   0          0        2    25.0
## 4         0    .         .        0.0   100 2   0          0        2     2.5
## 5         0    .         .        0.0   150 2   0          0        2     2.5
## 6         0    .         .        1.5   177 2   0          0        6     2.5
   .         .    .         .         .     .  .   .          .        .      .
   .         .    .         .         .     .  .   .          .        .      .
   .         .    .         .         .     .  .   .          .        .      .

##   PROPDMGEXP CROPDMG CROPDMGEXP WFO STATEOFFIC ZONENAMES LATITUDE LONGITUDE
## 1          K       0      .      .       .        .          3040      8812
## 2          K       0      .      .       .        .          3042      8755
## 3          K       0      .      .       .        .          3340      8742
## 4          K       0      .      .       .        .          3458      8626
## 5          K       0      .      .       .        .          3412      8642
## 6          K       0      .      .       .        .          3450      8748
   .          .       .      .      .       .        .            .         .
   .          .       .      .      .       .        .            .         .
   .          .       .      .      .       .        .            .         .

##   LATITUDE_E LONGITUDE_ REMARKS REFNUM
## 1       3051       8806    .         1
## 2          0          0    .         2
## 3          0          0    .         3
## 4          0          0    .         4
## 5          0          0    .         5
## 6          0          0    .         6 
   .          .          .    .         .
   .          .          .    .         .
   .          .          .    .         .

</pre>
</div>
```

**Consequences**

* The zero transformation requires roughly 500 MB, dimensions of 902297 rows by 37 columns.
* There were 918 distinct event names at this point.

<hr style="background : #F7261C; height : 15px"/>

### Transformation 1: Reading the data file

**Goal**

The goal of this transformation is to create a data frame called *sourceDF* to store all rows and specific columns from the source file. 

**Why?**

The source file contains more data than what is needed for this project. By selecting the only the required columns, the *sourceDF* will have all of the data it requires and nothing more.  

The required data, described in the **initial data fields** definition above, contains the numerical data needed to produce the results tables. These tables will provide the information necessary to answer the required questions.

1. **Across the United States, which types of events are most harmful with respect to population health?**
2. **Across the United States, which types of events have the greatest economic consequences?**


**How?**

The read.table function uses the colClasses argument to select the columns that make up the **initial data fields**. When the file is read, the requested data in the file is copied into *sourceDF*. 

**Consequences**

```{=html}

<div style="font-size : 14;">

<strong>Listing 1:</strong>  The memory size required to store the data is 50601984, the dimesions of sourceDF are 902297 by 7 and the head of the data frame is shown below.

<pre>
## 50601984 bytes
## [1] 902297      7
##    EVTYPE FATALITIES INJURIES PROPDMG PROPDMGEXP CROPDMG CROPDMGEXP
## 1 TORNADO          0       15    25.0          K       0           
## 2 TORNADO          0        0     2.5          K       0           
## 3 TORNADO          0        2    25.0          K       0           
## 4 TORNADO          0        2     2.5          K       0           
## 5 TORNADO          0        2     2.5          K       0           
## 6 TORNADO          0        6     2.5          K       0
       .              .        .      .           .       .
       .              .        .      .           .       .
       .              .        .      .           .       .
       
 </pre>
</div>

```

**Changes to data frame properties**

* The zero transformation read the full file, which had a data frame of of roughly 500 MB, dimensions of 902297 rows by 37 columns.
* The data frame *sourceDF* created by this transformation takes roughly 50 MB of memory and has dimensions of 902297 rows by 7 columns.
* The change in memory size is about 450 MB and the and the *sourceDF* changes from 37 to 7 columns. 
* There were 918 distinct event names at this point.

These changes should improve the execution time of the code by reducing the number of operations required to complete the analysis.

<hr style="background : #F7AB1C; height : 15px"/>

### Transformation 2: Removing non-contributing data points

**Goal**

The goal of this transformation is to remove data points (rows) that do not contribute to the numerical results of the analysis.

**Why?**

The analysis will sum the values of the **numeric fields** but cursory examination of the data shows thousands of data points with *FATALITIES* = 0, *INJURIES* = 0, *PROPDMG* = 0, and *CROPDMG*= 0. None of these values will contribute to the sums, so there is no reason to include them.

**How?**

The data is copied from *sourceDF* to *sourceDF* excluding the non-contributing points. 

NOTE: a side effect of this transformaion is several irrelevant data points are dropped from the data frame.

**Consequences**


```{=html}

<div style="font-size : 14;">
<strong>Listing 2a:</strong>  The output listing before transformation 2. Notice the rows after the tenth row. The rows 82, and 271399 do not make a contribution because their numerical fields are all zero. Row 246124 has an illegitimate event name, '?' but it still makes a contribution.
<pre>

## 50601984 bytes
## [1] 902297      7
##          EVTYPE          FATALITIES INJURIES PROPDMG PROPDMGEXP CROPDMG CROPDMGEXP
##      1  TORNADO                   0       15    25.0          K       0      .           
##      2  TORNADO                   0        0     2.5          K       0      .           
##      3  TORNADO                   0        2    25.0          K       0      .           
##      4  TORNADO                   0        2     2.5          K       0      .           
##      5  TORNADO                   0        2     2.5          K       0      .           
##      6  TORNADO                   0        6     2.5          K       0      .           
##      7  TORNADO                   0        1     2.5          K       0      .           
##      8  TORNADO                   0        0     2.5          K       0      .           
##      9  TORNADO                   1       14    25.0          K       0      .           
##     10  TORNADO                   0        0    25.0          K       0      .
##      .     .                      .        .      .           .       .      .
##      .     .                      .        .      .           .       .      .
##      .     .                      .        .      .           .       .      .
##     82     HAIL                   0        0       0                  0      .           
##      .     .                      .        .      .           .       .      .
##      .     .                      .        .      .           .       .      .
## 246124        ?                   0        0       5          K       0      .           
##      .     .                      .        .      .           .       .      .
##      .     .                      .        .      .           .       .      .
## 271399 Summary: Nov. 16           0        0       0                  0      .
##      .     .                      .        .      .           .       .      .
##      .     .                      .        .      .           .       .      .

</pre>

<strong>Listing 2b:</strong> The output listing after transformation 2. Notice the row with "Summary: Nov. 16" is not found in the transformed data frame. Even though "?" is an illegitimate name it still included in the data frame because it contributes to the calculation. The row with "HAIL" is included in the data frame, which might be unexpected, however, there are numerous rows with the event name "HAIL" that do contribute, so an instance of "HAIL" in the transformed data frame is expected.

<pre>
## 15315016 bytes
## [1] 254633      7
##    EVTYPE FATALITIES INJURIES PROPDMG PROPDMGEXP CROPDMG CROPDMGEXP
## 1 TORNADO          0       15    25.0          K       0      .           
## 2 TORNADO          0        0     2.5          K       0      .           
## 3 TORNADO          0        2    25.0          K       0      .           
## 4 TORNADO          0        2     2.5          K       0      .           
## 5 TORNADO          0        2     2.5          K       0      .           
## 6 TORNADO          0        6     2.5          K       0      .      
## .     .            .        .      .           .       .      .
## .     .            .        .      .           .       .      .
## .     .            .        .      .           .       .      .


## [1] "HAIL found"
## [1] "? found"
## [1] "Summary: Nov. 16 not found"
</pre>


```

**Changes to data frame properties**

* The *sourceDF* before the transformation required 50 MB of memory and had a dimension of 902297 rows by 7.
* After the transformation, the *sourceDF* date frame requires 15 MB of storage and has a dimension of  254633 rows and 7.
* The transformation reduced the data frame size by roughly 35 MB and reduced the dimensions by 647664 rows.

<hr style="background : #F7F71C; height : 15px"/>

### Transformation 3: Clear white spaces from strings

**Goal**

The goal is to change the string names to simplify comparisons that will have to be done to convert the data collectors names to NWS names.

**Why?**

This transformation is necessary for two reasons. First, white space at the beginning and ending of a string are included in string comparisons. When a name like "DUST" is compare to " DUST" the string will not match, even though they are expected to match. The second reason is the data collectors did not use consistent case usage. Names like *Black Ice* match the NWS naming convention, but *BLACK ICE* does not. Given the number of misspellings, inconsistent names, and other problems, all of the letters in a name are converted to lower case. Now, *Black Ice* and *BLACK ICE* are both spelled *black ice* and are compared to the NWS name, also all lower case letters.


**How?**

The data is copied from sourceDF back to sourceDF after triming the whitespace using *trimws* and converting all strings to lower case letters using *tolower*.

**Consequences**

```{=html}
<strong>Listing 3a:</strong> The listing shows the output of the data before Transform 3. Notice that all the strings in <em>EVTYPE</em>, <em>PROPDMGEXP</em>, and <em>CROPDMGEXP</em> are all upper case letters. In addition to the head of the data frame, the output includes row 408333. Though it is not appearant, the event associated with this row is ' FLASH FLOOD'.

<div style="font-size : 14; font-weight: bold;">
<pre>
## 15315016 bytes
## [1] 254633      7
##              EVTYPE  FATALITIES INJURIES PROPDMG PROPDMGEXP CROPDMG CROPDMGEXP
##      1      TORNADO           0       15    25.0          K       0           
##      2      TORNADO           0        0     2.5          K       0           
##      3      TORNADO           0        2    25.0          K       0           
##      4      TORNADO           0        2     2.5          K       0           
##      5      TORNADO           0        2     2.5          K       0           
##      6      TORNADO           0        6     2.5          K       0           
##      7      TORNADO           0        1     2.5          K       0           
##      8      TORNADO           0        0     2.5          K       0           
##      9      TORNADO           1       14    25.0          K       0           
##     10      TORNADO           0        0    25.0          K       0           
      .           .              .        .       .          .       .
      .           .              .        .       .          .       .
## 408333  FLASH FLOOD           0        0      50          K       0
      .           .              .        .       .          .       .
      .           .              .        .       .          .       .
      .           .              .        .       .          .       .

</pre>

<strong>Listing 3b:</strong> The listing shows the output of the after Transform 3. Also notice that all the strings in <em>EVTYPE</em>, <em>PROPDMGEXP</em>, and <em>CROPDMGEXP</em> have all lower case letters.
<pre>
## 15311912 bytes
## [1] 254633      7
##    EVTYPE FATALITIES INJURIES PROPDMG PROPDMGEXP CROPDMG CROPDMGEXP
## 1 tornado          0       15    25.0          k       0           
## 2 tornado          0        0     2.5          k       0           
## 3 tornado          0        2    25.0          k       0           
## 4 tornado          0        2     2.5          k       0           
## 5 tornado          0        2     2.5          k       0           
## 6 tornado          0        6     2.5          k       0           
   .   .              .        .       .          .       .
   .   .              .        .       .          .       .
   .   .              .        .       .          .       .

</pre>
<strong>Listing 3c:</strong> The listing shows the output of the data after Transform 3. The results show the results of searching for four strings. No string with a space at the beginning was found and no string with all upper case letters was found. The only string that was found is the string with no space and all lower case.
<pre>

## [1] " FLASH FLOOD not found"
## [1] "FLASH FLOOD not found"
## [1] " flash flood not found"
## [1] "flash flood found"
</pre>
</div>
```


**Changes to data frame properties**

* The *sourceDF* before Transformation 3 the frame data required 15315016 Bytes (~15 MB) of memory and had 902297 rows by 7.
* After Transformation 3 the data, date frame size was 15311912 Bytes with no changes to the dimensions.
* The transformation reduces the data frame size by roughly 3 kB.
* There were 918 distinct event names at this point.

<hr style="background : #009E11; height : 15px"/>

### Transformation 4: Fixing invalid names

**Goal**

The goal is to ensure any names that have no apparent relationship to the NWS names are accounted for.

**Why?**

Some of the data collector names have no apparent relationship to the NWS names. For example, the names, **?**, **apache county**, and **high** do not match the any name in the NWS. If they were removed from the data frame, then their impact would be lost, so their EVTYPE names are replaced with **Other**.

**How?**

Each *EVTYPE* name is compared to the invalid names. If a name matches one of the invalid names, the data frame's event name is replaced with the word "Other".

**Consequences**

```{=html}
<strong>Listing 4a:</strong> The listing shows the output of the data before Transform 4. To demonstrate the change of invalid names, the location of the '?' event was identified by a two pass 

<div style="font-size : 14; font-weight: bold;">
<pre>
## 15311912 bytes
## [1] 254633      7
##         EVTYPE FATALITIES INJURIES PROPDMG PROPDMGEXP CROPDMG CROPDMGEXP
##      1 tornado          0       15    25.0          k       0           
##      2 tornado          0        0     2.5          k       0           
##      3 tornado          0        2    25.0          k       0           
##      4 tornado          0        2     2.5          k       0           
##      5 tornado          0        2     2.5          k       0           
##      6 tornado          0        6     2.5          k       0           
##      .    .             .        .      .           .       .
##      .    .             .        .      .           .       .
## 246124       ?          0        0       5          k       0           
##      .    .             .        .      .           .       .
##      .    .             .        .      .           .       .
## [1] 52498

</pre>

<strong>Listing 4b:</strong> The listing shows the output of the data before Transform 4. 
<pre>
## 15311608 bytes
## [1] 254633      7
##         EVTYPE FATALITIES INJURIES PROPDMG PROPDMGEXP CROPDMG CROPDMGEXP
##      1 tornado          0       15    25.0          k       0           
##      2 tornado          0        0     2.5          k       0           
##      3 tornado          0        2    25.0          k       0           
##      4 tornado          0        2     2.5          k       0           
##      5 tornado          0        2     2.5          k       0           
##      6 tornado          0        6     2.5          k       0           
##      .    .             .        .      .           .       .
##      .    .             .        .      .           .       .
##      .    .             .        .      .           .       .
## 246124 Other            0        0       5          k       0
##      .    .             .        .      .           .       .
##      .    .             .        .      .           .       .

</pre>

</div>


<strong>Listing XXXX: </strong>.

<pre>
 15311608 bytes
 [1] 254633      7

         EVTYPE FATALITIES INJURIES PROPDMG PROPDMGEXP CROPDMG CROPDMGEXP
      1 tornado          0       15    25.0          k       0           
      2 tornado          0        0     2.5          k       0           
      .   .              .        .       .          .       .       . 
      .   .              .        .       .          .       .       . 
      .   .              .        .       .          .       .       . 
 188990 Other            6        0     0.0               0.00           
      .   .              .        .       .          .       .       . 
      .   .              .        .       .          .       .       . 
      .   .              .        .       .          .       .       . 
 435359 Other            0        4     0.0               0.00
      .   .              .        .       .          .       .       . 
      .   .              .        .       .          .       .       . 
      .   .              .        .       .          .       .       . 
</pre>
</div>
```


**Changes to data frame properties**

* The *sourceDF* before renaming the event names was 15311912 Bytes (~15 MB) of memory and had 254633 rows by 7 columns.
* After renaming the event names, the *sourceDF* date frame size was 15311608 Bytes.
* The *sourceDF* date frame has dimensions were unchanged.
* The transformation reduces the data frame size by roughly 304 B.
* The transformation affected 57 names, which accounts the small change in memory requirements.
* There were 249 distinct event names at this point.

<hr style="background : #004FEE; height : 15px"/>

### Transformation 5:  Unify the event names

**Why?**

The data collectors did not use consistent names for single events. For example, the NWS event "Thunderstorm Wind" was reported by the following

```{=html}
  <div style="font-size : 8px; font-weight: bold;"> <!-- Thunder storm events -->
```

THUDERSTORM WINDS, THUNDEERSTORM WINDS, THUNDERESTORM WINDS, THUNDERSTORM, THUNDERSTORM  WINDS, Thunderstorm Wind, THUNDERSTORM WIND, THUNDERSTORM WIND (G40), THUNDERSTORM WIND 50, THUNDERSTORM WIND 52,  THUNDERSTORM WIND 56, THUNDERSTORM WIND 59, THUNDERSTORM WIND 59 MPH, THUNDERSTORM WIND 59 MPH., THUNDERSTORM WIND 60 MPH, THUNDERSTORM WIND 65 MPH, THUNDERSTORM WIND 65MPH, THUNDERSTORM WIND 69, THUNDERSTORM WIND 98 MPH,  THUNDERSTORM  THUNDERSTORM WIND G55, THUNDERSTORM WIND G60,  THUNDERSTORM WIND G61, THUNDERSTORM WIND TREES, THUNDERSTORM 
WIND. THUNDERSTORM WIND/ TREE, THUNDERSTORM WIND/ TREES, THUNDERSTORM WIND/AWNING, THUNDERSTORM WINDS, THUNDERSTORM WINDS, THUNDERSTORM WINDS 13, THUNDERSTORM WINDS 2, THUNDERSTORM WINDS 50, THUNDERSTORM WINDS 52, THUNDERSTORM WINDS 53, THUNDERSTORM WINDS 60, THUNDERSTORM WINDS 61, THUNDERSTORM WINDS 62, THUNDERSTORM WINDS 63 MPH, THUNDERSTORM WINDS G, THUNDERSTORMWINDS G60, THUNDERSTORM WINDS., THUNDERSTORM WINDS53, THUNDERSTORMS WIND, THUNDERSTORMS WINDS, THUNDERSTORMW, THUNDERSTORMW 50, THUNDERSTORMW WINDS, THUNDERSTORMWINDS, THUNDERSTROM WIND, THUNDERSTROM WINDS, THUNDERTORM WINDS, THUNDERTSORM WIND,  THUNDESTORM WINDS, THUNERSTORM WINDS, TSTM, TSTM WIND, Tstm Wind, TSTM WIND,  TSTM WIND  (G45), TSTM WIND (41), TSTM WIND (G35), TSTM WIND (G40),  TSTM WIND (G45), TSTM WIND (G45), TSTM WIND 40, TSTM WIND 45, TSTM WIND 50, TSTM WIND 51, TSTM WIND 52, TSTM WIND 55, TSTM WIND 65), TSTM WIND DAMAGE, TSTM WIND G45, TSTM WIND G58, TSTM WINDS, TSTM WND, TSTMW
```{=html}
  </div> 
```

If these names are not changed to the single NWS name before the data is grouped, they will create dozens of groups and the analysis will produce invalid results for "Thunderstorm Wind". The analysis must unify the disparate names chosen by the data collectors to the NWS names.

**How?**
The UnifyNames function will check each name against a set of substrings. If the name matches a substring, the EVTYPE will be changed to the NWS type. The result will be stored in *validDF*.

Prior to writing the code, a list of data collector event names was generated. Each name was assigned an NWS name using the National Weather Service Instruction 10-1605. From this list, each name was assigned a substring and the substrings were used to determine the correct NWS name.


**Consequences**

Listing 5 shows partial results of the unifying names Prior to unifing the first event name was "tornado". After unifying the names, the first eavent became "Tornado", which is the correct NWS name.

In addition to the name changes, further analysis showed that the number of distinct event names went from 239 to 46. This is the result of unifying the names.

```{=html}
<strong>Listing 5: </strong>.

<div style="font-size : 14; font-weight: bold;">
<pre>
 15283600 bytes
 [1] 254633      7
    EVTYPE FATALITIES INJURIES PROPDMG PROPDMGEXP CROPDMG CROPDMGEXP
 1 Tornado          0       15    25.0          k       0           
 2 Tornado          0        0     2.5          k       0           
 3 Tornado          0        2    25.0          k       0           
 4 Tornado          0        2     2.5          k       0           
 5 Tornado          0        2     2.5          k       0           
 6 Tornado          0        6     2.5          k       0
      .             .       .       .           .       .
      .             .       .       .           .       .
      .             .       .       .           .       .
</pre>
</div>
```

* There were 249 distinct event names at this point.

**Changes to data frame properties**
* The *sourceDF* before unifying names was 15311608 Bytes (~15 MB) of memory and had 254633 rows by 7 columns.
* After unifying names, the *sourceDF* date frame size was 15283600 Bytes.
* The *sourceDF* date frame has dimensions were unchanged.
* The transformation reduces the data frame size by roughly 28 kB.
* There were 46 distinct event names at this point.


<hr style="background : #5C05FE; height : 15px"/>

### Transformation 6: Set up the analysis data frame

**Why?**

The goal of this analysis is to establish two points: the weather events responsible for the worst publich health costs and the weather events responsible for the worse economic damage. To do this, the analysis must have a means of assessing the public health costs and economic damage. 

The data provided by NOAA does not have public health or economic loss cost categories, so they must be created. Without explicit guidelines, the options for calculating the costs of the damage is extensive. For simplicity, the analysis uses the following algorithm:

* public health (HEALTH) are FATALITIES + INJURIES
* economic costs (ECONOMIC) are PROPDMG * PROPDMGEXP + CROPDMG * CROPDMGEXP

**How?**

The *validDF* is mutated to perform the calculations, the *EVTYPE*, **HEALTH**, and **ECONOMIC** events are selected and stored stored in *analysisDF*.

**Consequences**

```{=html}
<strong>Listing XXXX: </strong>.

<div style="font-size : 14; font-weight: bold;">
<pre>
 7133720 bytes
 [1] 254633      3
    EVTYPE HEALTH ECONOMIC
 1 Tornado         15 0.0250
 2 Tornado          0 0.0025
 3 Tornado          2 0.0250
 4 Tornado          2 0.0025
 5 Tornado          2 0.0025
 6 Tornado          6 0.0025
      .             .   .
      .             .   .
      .             .   .
 </pre>
</div>
```


**Changes to data frame properties**
* The *validDF* before unifying names was 15283600 Bytes (~15 MB) of memory and had 254633 rows by 7 columns.
* After unifying names, the *analysisDF* date frame size was 7133720 Bytes (~7MB).
* The *analysisDF* date frame has dimensions changed to 254633 rows by 3 columns.
* The transformation reduces the data frame size by roughly 8 MB.
* There were 46 distinct event names at this point.


<hr style="background : #6B4DA4; height : 15px"/>


### Transformation 7: Group the data by EVTYPE

**Why?**

The goal of this project is to answer two questions: 

1. **Across the United States, which types of events are most harmful with respect to population health?**
2. **Across the United States, which types of events have the greatest economic consequences?**

The emphasis of these questions is "which types of events?" In other words, the data organization has to group the data around events, not data points as they currently are. To create the target system, the casualty and economic losses for each data point associated with a given event type must be summed and assigned to the **HEALTH** and **ECONOMIC** columns for that event.

For example, the *analysisDF* was written to a csv file and the file was opened in a spreadsheet. After sorting the data based on *EVTYPE*, the **HEALTH** and **ECONOMIC** all data points with *EVTYPE* equal to "Avalanche" were summed together. The result of the sums of the 269 "Avalanche" events is a total of 395 HEALTH and about $3.7 million in damages. 

This result is an example of one grouped event type. However, the analysis relies on having the data for all events. This would be too diffcult to do by hand, so the computer needs to take care of it,

**How?**

The *analysisDF* is grouped by *EVTYPE* then piped to summarize_at(c("HEALTH", "ECONOMIC"), sum). The summarize_at() function sums the values of **HEALTH** and **ECONOMIC** respectivly. After the grouping and summing is complete, the data frame is ordered by *EVTYPE*. The result is stored in the *analysisTable* data frame.

**Consequences**
The results for the 

```{=html}
<strong>Listing XXXX: </strong>.

<div style="font-size : 14; font-weight: bold;">
<pre>
 5240 bytes
 [1] 46  3
 # A tibble: 46 × 3
    EVTYPE                HEALTH    ECONOMIC
    <chr>                      <dbl>     <dbl>
  1 Astronomical Low Tide          0     0.32 
  2 Avalanche                    395     3.72 
  3 Blizzard                     959   777.   
  4 Coastal Flood                 15   408.   
  5 Cold/Wind Chill              228   100.   
  6 Debris Flow                   99   347.   
  7 Dense Fog                   1156    22.8  
  8 Dense Smoke                    0     0.1  
  9 Drought                        4 13519.   
 10 Dust Devil                    45     0.719
         .                        .      .
         .                        .      .
         .                        .      .
</pre>
</div>
```


**Changes to data frame properties**
* The *analysisDF* before unifying names was 7133720 Bytes (~7 MB) of memory and had 254633 rows by 3 columns.
* After grouping the data, the *analysisTable* date frame size was 5240 Bytes.
* The *analysisTable* date frame has dimensions changed to 46 rows by 3 columns.
* The transformation reduces the data frame size by roughly 7 MB.
* There were 46 distinct event names at this point.


<hr style="background : #1B004D; height : 15px"/>


### Transformation 8: Creating the "Damage Tables"

**Why?**

The goal of the project is to find the worst events in terms of public health and economics. However, the *analysisTable* cannot be ordered by both categories simultaneously. The only way to accomplish this is to create a copy of the *analysisTable* ans sort one table by **HEALTH** and the other by **ECONOMIC**. These tables provide the necessary information to complete the analysis.

To provide additional understanding of what the tables mean, two additional rows are added to the tables. The first computes the percent damage for each damage type and the second is the accumulated percentdamage for each damage type. The tables are ordered by the greatest to least amount of damage, so the accumulated percentage is the amount of damage caused by the first n-events.

Assuming the emergency response planners might want to focus on the worst 90% of weather events, this table will make it an easy task. Listing 8 will demonstrate this process. 

**How?**

To find the worst damages in term of public health and economic losses, the *analysisTable* must be separated into two data frames: one for **HEALTH**, and the other for **ECONOMIC**. Each table is ordered by their specific damage types from greatest to least. After the worst public health damage table is completed, the **PERCENT_CASUALTY** and the **ACC_PERCENT_CASUALTY** are computed for each event type. The same is done for **ECONOMIC**.

**Consequences**

The new damage tables, shown in Listing 8, are organized by damage type. The first table is organized by **HEALTH** as can be seen by the **HEALTH** column. The **ECONOMIC** column is not ordered making it easier to generate one of the images. This will be clearer when the images are generated. The second table is ordered by **ECONOMIC** and the **HEALTH** column is not ordered.

In both tables, each event is assigned a percentage representing the amount of damage that event caused. The accumulated percentage column shows the amount of damage caused by the first n-events. 

For example, if the user wants to know which events are responsible for 90% of the HEALTH, they can look down the **ACC_PERCENT_CASUALTY** column until they find the first number greater than or equal to 90. In this case, the number is 90.6 in the "High Wind" rows. This means, the "Tornado", "Excessive Heat", "Thunderstorm Wind", "Flood", "Lightning", "Winter Weather", "Flash Flood", "High Wind" account for approximately 90% of **HEALTH**.


```{=html}
<strong>Listing XXXX: </strong>.

<div style="font-size : 14; font-weight: bold;">
<pre>
## 6224 bytes
## [1] 46  5
## # A tibble: 15 × 5
##    EVTYPE            HEALTH  ECONOMIC PERCENT ACC_PERCENT
##    <chr>                  <dbl>   <dbl>   <dbl>       <dbl>
##  1 Tornado                96997 52057.   62.3          62.3
##  2 Excessive Heat         12363   525.    7.94         70.2
##  3 Thunderstorm Wind      10153 10939.    6.52         76.8
##  4 Flood                   7280 28498.    4.68         81.4
##  5 Lightning               6049   951.    3.89         85.3
##  6 Winter Weather          3350  4225.    2.15         87.5
##  7 Flash Flood             2944 17519.    1.89         89.4
##  8 High Wind               1848  5388.    1.19         90.6
##  9 Wildfire                1698  6360.    1.09         91.7
## 10 Winter Storm            1584  1790.    1.02         92.7
## 11 Hail                    1512 17334.    0.971        93.6
## 12 Hurricane/Typhoon       1468 14963.    0.943        94.6
## 13 Heavy Snow              1160  1071.    0.745        95.3
## 14 Dense Fog               1156    22.8   0.743        96.1
## 15 Rip Current             1107     0.2   0.711        96.8
             .                        .      .      .            .
             .                        .      .      .            .
             .                        .      .      .            .
</pre>
<pre>
## 6224 bytes
## [1] 46  5
## # A tibble: 15 × 5
##    EVTYPE                  HEALTH ECONOMIC PERCENT ACC_PERCENT
##    <chr>                        <dbl>  <dbl>   <dbl>       <dbl>
##  1 Tornado                      96997 52057.  27.8          27.8
##  2 Flood                         7280 28498.  15.2          43.1
##  3 Flash Flood                   2944 17519.   9.37         52.5
##  4 Hail                          1512 17334.   9.27         61.7
##  5 Hurricane/Typhoon             1468 14963.   8.00         69.7
##  6 Drought                          4 13519.   7.23         77.0
##  7 Thunderstorm Wind            10153 10939.   5.85         82.8
##  8 Wildfire                      1698  6360.   3.40         86.2
##  9 High Wind                     1848  5388.   2.88         89.1
## 10 Winter Weather                3350  4225.   2.26         91.4
## 11 Tropical Storm                 449  3259.   1.74         93.1
## 12 Frost/Freeze                     5  1816.   0.971        94.1
## 13 Winter Storm                  1584  1790.   0.958        95.0
## 14 Heavy Rain                     386  1525.   0.815        95.8
## 15 Extreme Cold/Wind Chill        574  1463.   0.783        96.6
             .                        .      .      .            .
             .                        .      .      .            .
             .                        .      .      .            .
</pre>
</div>
```


**Changes to data frame properties**
* The *analysisDF* before unifying names was 7133720 Bytes (~7 MB) of memory and had 254633 rows by 3 columns.
* After grouping the data, the *analysisTable* date frame size was 5240 Bytes.
* The *analysisTable* date frame has dimensions changed to 46 rows by 3 columns.
* The transformation reduces the data frame size by roughly 7 MB.
* There were 46 distinct event names at this point.



```{=html}
</div>   <!-- Base page -->
```

## Processing Code

### Required Libraries 

```{r libraries}
# Data Presentation Phase ======================================================
# This code block takes the "worstHEALTH" and the "worstLosses" tables from
# the "resultTables" an converts them to knitr:Kable tables.
# ==============================================================================
# knitr      -- The stringr library has several string manipulation functions,
#               the function that converts strings to a title
#               format. The format ensures the first letter of each word in a
#               string is converted to an upper case letter.
#
#               It is used in the Setup Phase: Program Constants section.
library(knitr)

# stringr    -- The stringr library has several string manipulation functions,
#               the str_to_title function that converts strings to a title
#               format. The format ensures the first letter of each word in a
#               string is converted to an upper case letter.
#
#               It is used in the Setup Phase: Program Constants section.
library(stringr)

# dplyr      -- The dplyr library has several functions related to data
#               wrangling,and the %>% operator. These functions are used
#               throughout the code.
library(dplyr)

# rlist      -- The rlist library has several functions to make list
#               manipulation easier. The list.append function is used through
#               the code.
library(rlist)

# kableExtra -- The kableExtra library adds to the functionality of knit::kable,
#               the basic table generator in knitr. This functionality includes
#               support for fonts, colors, table styles, and so on.
#               The knitr::kable and the kableExtra functions are used in the
#               Execute Phase to prepare the data for display.
#
#               Development Note: This should bem oved inside the Analysis
#               Phase: Construct Analysis Tables in the future.
library(kableExtra)

# ggplot2    -- all of the plots made by StormCloud are made using gplot.
#               The plot code is used in the Make Bar Images and Make Human vs.
#               Economic Image.
#
library(ggplot2)

# ggrepel    -- ggrepel is used as part of the Make Human vs. Economic Image. It
#               helps to separate point labels on the plot.
#               This code is used in the Make Human vs. Economic Image.
library(ggrepel)

# cowplot    -- cowplot to make a create a multiple plot to allow the results of
#               more than one jurisdiction to be display in plot. Since the
#               example in this demonstration includes only one jurisdiction,
#               cowplot is not required. However, StormCloud supports multiple
#               jurisdictions so it is included in the code.
#               The cowplot code is used in the Make Bar Images and Make Human
#               vs. Economic Image.
library(cowplot)

```

### "Constants"

```{r constants}
# Strictly speaking, R does no support constants, so the following are all 
# variables. However, these variables are treated as constants, i.e., there 
# value should not be changed once set. They are written in all upper case 
# letters to distinguish then from regular variables.

URL      =
  "https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2FStormData.csv.bz2"
DATAFILE = "storm.csv.bz2"

HEALTH_IDX    = 1
ECONOMIC_IDX        = 2

DAMAGE_IDX     = c(HEALTH_IDX, ECONOMIC_IDX)
DAMAGE_NAMES   = c("HEALTH", "ECONOMIC")
DAMAGE_SELECT  = c("c('EVTYPE', 'HEALTH')",
                  "c('EVTYPE', 'ECONOMIC')")
AXIS_NAMES     = c("c('EVTYPE', 'HEALTH')",
                  "c('EVTYPE', 'ECONOMIC')")
DAMAGE_REORDER = c("reorder(EVTYPE, -HEALTH)",
                   "reorder(EVTYPE, -ECONOMIC)")

TABLE_FIELDS <-  c("c('EVTYPE', 'HEALTH', 'PERCENT', 'ACC_PERCENT')",
                  "c('EVTYPE', 'ECONOMIC', 'PERCENT', 'ACC_PERCENT')")
AXIS_LABELS <- list(
    c("Event Type", "HEALTH", "Percent of Total", "Accumulated Percent"),
    c("Event Type", "Losses (in millions)",
      "Percent of Total", "Accumulated Percent"))

VERBOSE                   = TRUE    # list results of each transformation
ALL_DATA                  = FALSE    # include all data points
CONTRIBUTING_EVENTS       = TRUE    # include contributing events only
CLEAR_EVENTS              = TRUE    # includes all cleared events only
FIX_EVENTS                = TRUE    # excludes weird names    
UNIFIED_EVENTS            = TRUE    # include all un-unified events

```

### Unify Names

```{r Unify Names}
# UnifyNames ===================================================================
# 1) rename "validDF" to "sourceDF"
# 2) based on the an extensive study of the event names in the data file and the
#    NWS event names and classifications, I developed a mapping from the file
#    names to the NWS names;
# 3) the file to NWS mappings were turned in to gsub statements
# 4) each event name in "sourceDF" is converted from the file name to the NWS name.
# ------------------------------------------------------------------------------
# input variables
#        validDF--renamed to "sourceDF". The "validDF" is the original "sourceDF"
#                 after trimming white space, excluding rows that do not
#                 contribute,
#
# constants
# NONE
#
# LOCAL VARIABLES
#        sourceDF--"validDF" is the "sourceDF" after cleaning, removing all non-
#                  contributing values, and removing all invalid events.
#
# returns sourceDF
# ==============================================================================

UnifyNames <- function(sourceDF) {
  sourceDF$EVTYPE <-
    gsub("^marine hail$", "Marine Hail",
    gsub("^marine high wind$", "Marine High Wind",
    gsub("^marine strong wind$", "Marine Strong Wind",
    gsub("^marine thunderstorm wind$", "Marine Thunderstorm Wind",
    gsub("^marine tstm wind$", "Marine Thunderstorm Wind",
    gsub("^storm force winds$", "Marine Strong Wind",
    gsub("^(high|heavy|rough).+seas.*$", "Marine Strong Wind",
    gsub("^(high|heavy).+swells.*$", "Marine High Wind",
    gsub("^(typhoon|hurricane.*)$", "Hurricane/Typhoon",
    gsub("^tsunami$", "Tsunami",
    gsub("^tropical depression$", "Tropical Depression",
    gsub("^tropical storm.*$", "Tropical Storm",
    gsub("^drowning$", "Rip Current",
    sourceDF$EVTYPE)))))))))))))

  sourceDF$EVTYPE <-
    gsub("^.*coastal.*$", "Coastal Flood",
    gsub("^.*erosion.*$", "High Surf",
    gsub("^.*tidal.*$", "Coastal Flood",
    gsub("^astronomical high tide$", "Coastal Flood",
    gsub("^storm surge.*$", "Storm Tide",
    gsub("^high.+(tides|waves).*$", "Storm Tide",
    gsub("^rogue.+$", "Storm Tide",
    sourceDF$EVTYPE)))))))

  sourceDF$EVTYPE <-
    gsub("^lake.*snow$", "Lake-Effect Snow",
    gsub("^lake.*$", "Lakeshore Flood",
    sourceDF$EVTYPE))

  sourceDF$EVTYPE <-
    gsub("^(dam break|ice floes|ice jam( flood.+|))$", "Flash Flood",
    gsub("^.+small stream urban$", "Flash Flood",
    gsub("^urban.+(small|stream).*$", "Flash Flood",
    gsub("^(small|minor).+flood.*$", "Flash Flood",
    gsub("^flood.+flash.*$", "Flash Flood",
    gsub("^flash.*$", "Flash Flood",
    sourceDF$EVTYPE))))))

  sourceDF$EVTYPE <-
    gsub("^fog and cold temperatures$", "Freezing Fog",
    gsub("^freezing fog$", "Freezing Fog",
    gsub("^.*freezing (drizzle|rain|spray).*$", "Winter Weather",
    sourceDF$EVTYPE)))

  # # must come after marine
  sourceDF$EVTYPE <-
    gsub("^hail.*$", "Hail",
    gsub("^small hail$", "Hail",
    gsub("^thunderstorm.+hail$", "Hail",
    gsub("^.*tstm.+hail$", "Hail",
    gsub("^(wind|gusty).+hail$", "Hail",
    sourceDF$EVTYPE)))))

  sourceDF$EVTYPE <-
    gsub("^(wind|non|gusty).+wind.*$", "High Wind",
    gsub("^(strong|gusty).*$", "Strong Wind",
    gsub("^(rain.+wind|wind.+rain)$", "High Wind",
    gsub("^wind.*$", "High Wind",
    gsub("^gradient wind$", "Rip Current",
    gsub("^rip current.*$", "Rip Current",
    sourceDF$EVTYPE))))))

  sourceDF$EVTYPE <-
    gsub("^(wind|gusty).+rain$", "Heavy Rain",
    gsub("^(unseasonal|hvy|high.+heavy).+rain.*$", "Heavy Rain",
    gsub("^rain(.*|fall)$", "Heavy Rain",
    gsub("^heavy (shower|precipitation)$", "Heavy Rain",
    gsub("^heavy.(rain|rains)$", "Heavy Rain",
    gsub("^heavy rain/severe weather$", "Heavy Rain",
    gsub("^(torrential|record|excessive) rainfall$", "Heavy Rain",
    sourceDF$EVTYPE)))))))

  sourceDF$EVTYPE <-
    gsub("^heavy rain/lightning", "Lightning",
    gsub("^thunderstorm.+lightning", "Lightning",
    gsub("^tstm.+lightning", "Lightning",
    gsub("^ligntning$", "Lightning",
    gsub("^lighting$", "Lightning",
    gsub("^ligntning+rain$", "Heavy Rain",
    gsub("^lightning.*$", "Lightning",
    sourceDF$EVTYPE)))))))

  sourceDF$EVTYPE <-
    gsub("^thunderstorm.+flood($|ing$)", "Flood",
    gsub("^high.+water$", "Flood",
    gsub("^(flood|river|rural|major|break).+$", "Flood",
    gsub("^urban.+flood.*$", "Flood",
    gsub("^ice jam flooding$", "Flood",
    gsub("^rapidly rising water$", "Flood",
    gsub("^flood$", "Flood",
    gsub("^heavy rain(s/flooding| and flood)$", "Flood",
    gsub("^heavy snow/high winds & flood$", "Flood",
    sourceDF$EVTYPE)))))))))

  sourceDF$EVTYPE <-
    gsub("^thunder.+$", "Thunderstorm Wind",
    gsub("^tstm.+$", "Thunderstorm Wind",
    gsub("^.+burst.*$", "Thunderstorm Wind",
    gsub("^severe thunder.+$", "Thunderstorm Wind",
    gsub("^severe turb.+$", "Thunderstorm Wind",
    gsub("^whirlwind$", "Thunderstorm Wind",
    gsub("^(thude|thune|tund|thundeer).+$", "Thunderstorm Wind",
    sourceDF$EVTYPE)))))))

  sourceDF$EVTYPE <-
    gsub("^(cold air torn|torn).+$", "Tornado",
    gsub("^(gustnado|landspout)$", "Tornado",
    sourceDF$EVTYPE))

  sourceDF$EVTYPE <-
    gsub("^.*heavy snow$", "Heavy Snow",
    gsub("^(excessive|high|heavy).+snow$", "Heavy Snow",
    gsub("^record snow$", "Winter Weather",
    sourceDF$EVTYPE)))

  sourceDF$EVTYPE <-
    gsub("^extreme.+chill$|^(extended|extreme|record) cold$", "Extreme Cold/Wind Chill",
    gsub("^hypo.+$", "Extreme Cold/Wind Chill",
    sourceDF$EVTYPE))

  sourceDF$EVTYPE <-
    gsub("^high.+blizzard.*$", "Blizzard",
    gsub("^.*blowing snow$", "Blizzard",
    gsub("^.*blizzard.*$", "Blizzard",
    gsub("^high.+wind.*$", "High Wind",
    gsub("^snow/high winds$", "Blizzard",
    sourceDF$EVTYPE)))))

  sourceDF$EVTYPE <-
    gsub("^heavy.+ice$", "Winter Storm",
    gsub("^heavy.+storm$", "Winter Storm",
    gsub("^heavy.+winds$", "Winter Storm",
    gsub("^heavy.+snow.*$", "Winter Storm",
    gsub("^winter.+storm$", "Winter Storm",
    gsub("^.*winter storm.+$", "Winter Storm",
    sourceDF$EVTYPE))))))

  sourceDF$EVTYPE <-
    gsub("^.*sl(ide|ump).*$", "Debris Flow",
    gsub("^(snow|sleet|glaze).+ice storm$", "Winter Weather",
    gsub("^glaze.*$", "Winter Weather",
    sourceDF$EVTYPE)))


  sourceDF$EVTYPE <-
    gsub("^cool and wet$", "Winter Weather",
    gsub("^(late|light).+snow.*$", "Winter Weather",
    gsub("^.*winter storm.+$", "Winter Storm",
    gsub("^(rain.snow|snow.rain)$", "Winter Weather",
    gsub("^falling snow/ice$", "Winter Weather",
    gsub("^wint.+$", "Winter Weather",
    sourceDF$EVTYPE))))))

  sourceDF$EVTYPE <-
    gsub("^.*drought.*$", "Drought",
    gsub("^.*heat.*$", "Excessive Heat",
    gsub("^hyper.+$", "Excessive Heat",
    gsub("^.*warm.*$", "Heat",
    sourceDF$EVTYPE))))

  sourceDF$EVTYPE <-
    gsub("^dust storm.*$", "Dust Storm",
    gsub("^blowing dust$", "Dust Storm",
    gsub("^.*waterspout.*$", "Waterspout",
    gsub("^.*dust devil.*$", "Dust Devil",
    sourceDF$EVTYPE))))

  sourceDF$EVTYPE <-
    gsub("^.*(frost|freeze).*$", "Frost/Freeze",
    sourceDF$EVTYPE)

  sourceDF$EVTYPE <-
    gsub("^ice storm$", "Ice Storm",
    gsub("^ic(e|y).*$", "Winter Weather",
    gsub("^.*mix.*$", "Winter Weather",
    sourceDF$EVTYPE)))

sourceDF$EVTYPE <-
  gsub("^snow.*$", "Winter Weather",
  gsub("^sleet$", "Winter Weather",
  gsub("^.*cold.*$", "Cold/Wind Chill",
  gsub("^low.*$", "Cold/Wind Chill",
  sourceDF$EVTYPE))))

sourceDF$EVTYPE <-
  gsub("^cold.*(.*|temperature|wave|winds|wind chill)$", "Cold/Wind Chill",
  gsub("^high.+cold$", "Cold/Wind Chill",
  gsub("^.*cold.*$", "Cold/Wind Chill",
  gsub("^low.*$", "Cold/Wind Chill",
  sourceDF$EVTYPE))))

  sourceDF$EVTYPE <-
    gsub("^(high|heavy|rough|hazardous).+surf.*$", "High Surf",
    gsub("^avalanc.*$", "Avalanche",
    gsub("^seiche$", "Seiche",
    gsub("^volcanic ash$", "Volcanic Ash",
    gsub("^astronomical low tide$", "Astronomical Low Tide",
    gsub("^black ice$", "Winter Weather",
    gsub("^excessive wetness$", "Winter Weather",
    gsub("^rainstorm$", "Heavy Rain",
    gsub("^heavy precipitation$", "Heavy Rain",
    gsub("^(dense|.*)fog$", "Dense Fog",
    gsub("^falling snow/ice$", "Winter Weather",
    sourceDF$EVTYPE)))))))))))

  sourceDF$EVTYPE <-
    gsub("^.*fire.*$", "Wildfire",
    gsub("^.*funnel.*$", "Funnel Cloud",
    gsub("^.*smoke$", "Dense Smoke",
    sourceDF$EVTYPE)))
  if (VERBOSE) {
    print(paste0("sourceDF ", dim(sourceDF)))
    print(head(sourceDF))
  }

  return (sourceDF)
}

```

```{r processing}

  if (!file.exists(DATAFILE)) {
    retrieve = download.file(URL, DATAFILE, mode = "wb")

    if (is.null(retrieve)) {
      print("ERROR: could not access ", url)
      stop()
    }
  }

```

### Transformation 0:  No transformations

```{r}
# This code is used to measure the size of a data.frame with the entire contents
# of the data file.

if (VERBOSE & ALL_DATA) {
  sourceDF <- read.table(DATAFILE, sep = ",", header = TRUE)

  print(object.size(sourceDF))
  print(dim(sourceDF))
  print(head(sourceDF))
  
  knitr::knit_exit()
}


```

### Transformation 1: Reading the data file

```{r transformations}
sourceDF <- read.table(DATAFILE, stringsAsFactors = FALSE, sep = ",",
                       colClasses = c(rep("NULL",7), NA, rep("NULL",14),
                                      rep(NA, 6), rep("NULL",9)), header = TRUE)
if (VERBOSE) {
  print(object.size(sourceDF))
  print(dim(sourceDF))
  print(head(sourceDF))
}

```

### Transformation 2: Removing non-contributing data points

```{r}

if (CONTRIBUTING_EVENTS) {
    sourceDF <- sourceDF[sourceDF$FATALITIES != 0 | sourceDF$INJURIES != 0 |
                         sourceDF$PROPDMG != 0 | sourceDF$CROPDMG != 0, ]

  if (VERBOSE) {
    print(object.size(sourceDF))
    print(dim(sourceDF))
    print(head(sourceDF))

    if ('HAIL' %in% sourceDF$EVTYPE){
      print("HAIL found")
    } else {
      print("HAIL not found")
    }
    
    if ('?' %in% sourceDF$EVTYPE){
      print("? found")
    } else {
      print("? not found")
    }
    
    if ('Summary: Nov. 16' %in% sourceDF$EVTYPE){
      print("Summary: Nov. 16 found")
    } else {
      print("Summary: Nov. 16 not found")
    }
  }

} else {
  write.csv(sourceDF, "./all_evts.csv")

  if (VERBOSE) {
    print(object.size(sourceDF))
    print(dim(sourceDF))
    print(head(sourceDF, n=10))
    print(sourceDF[82,])
    print(sourceDF[246124,])
    print(sourceDF[271399,])
    print(sourceDF[278098,])
    # knitr::knit_exit()
  }
}

if (VERBOSE) {
  print(object.size(sourceDF))
  print(dim(sourceDF))
  print(head(sourceDF))
}

```

### Transformation 3: Clear white spaces from strings

```{r}

if (CLEAR_EVENTS) {
  sourceDF$EVTYPE     <- trimws(sourceDF$EVTYPE, which = c("both"))
  sourceDF$PROPDMGEXP <- trimws(sourceDF$PROPDMGEXP, which = c("both"))
  sourceDF$CROPDMGEXP <- trimws(sourceDF$CROPDMGEXP, which = c("both"))
  sourceDF$EVTYPE     <- tolower(sourceDF$EVTYPE)
  sourceDF$PROPDMGEXP <- tolower(sourceDF$PROPDMGEXP)
  sourceDF$CROPDMGEXP <- tolower(sourceDF$CROPDMGEXP)
  
  if (VERBOSE) {
    print(object.size(sourceDF))
    print(dim(sourceDF))
    print(head(sourceDF))
    if (' FLASH FLOOD' %in% sourceDF$EVTYPE){
      print(" FLASH FLOOD found")
    } else {
      print(" FLASH FLOOD not found")
    }
    if ('FLASH FLOOD' %in% sourceDF$EVTYPE){
      print("FLASH FLOOD found")
    } else {
      print("FLASH FLOOD not found")
    }
    if (' flash flood' %in% sourceDF$EVTYPE){
      print(" flash flood found")
    } else {
      print(" flash flood not found")
    }
    if ('flash flood' %in% sourceDF$EVTYPE){
      print("flash flood found")
    } else {
      print("flash flood not found")
    }
  }
} else {
  if (VERBOSE) {
    print(object.size(sourceDF))
    print(dim(sourceDF))
    print(head(sourceDF, n=10))
    print(sourceDF[sourceDF$EVTYPE == " FLASH FLOOD",])
    # knitr::knit_exit()
  }
}

```

### Transformation 4: Fixing invalid names

```{r}

if (FIX_EVENTS) {
  sourceDF$EVTYPE <-
    gsub("\\?", "Other",
    gsub("^high$", "Other",
    gsub("^marine accident$", "Other",
    gsub("^marine mishap$", "Other",
    gsub("^other$", "Other",
    gsub("^apache county$", "Other",
    sourceDF$EVTYPE))))))
  
  if (VERBOSE) {
    print(object.size(sourceDF))
    print(dim(sourceDF))
    print(head(sourceDF))
    print(sourceDF[52498, ])
  }
} else {
  print(object.size(sourceDF))
  print(dim(sourceDF))
  print(head(sourceDF))
  print(sourceDF[sourceDF$EVTYPE == "?", ])
  print(which(rownames(sourceDF) == 246124))
  knitr::knit_exit()
}

```


### Transformation 5: Unify the event names

```{r}

validDF    <- UnifyNames(sourceDF)


if (VERBOSE) {
  print(object.size(validDF))
  print(dim(validDF))
  print(head(validDF))
}

```

### Transformation 6: Set up the analysis data frame

```{r}

analysisDF <- validDF %>% ungroup(.) %>%
  mutate (PROPDMGEXP = ifelse(PROPDMGEXP == 'k', 1000.,
                              ifelse(PROPDMGEXP == 'm', 1000000., 1.)),
          CROPDMGEXP = ifelse(CROPDMGEXP == 'k', 1000.,
                              ifelse(CROPDMGEXP == 'm', 1000000., 1.) ),
          PROPDMG       = PROPDMG * PROPDMGEXP,
          CROPDMG       = CROPDMG * CROPDMGEXP,
          HEALTH    = FATALITIES + INJURIES,
          ECONOMIC     = (PROPDMG + CROPDMG)/1000000.0
          ) %>%
  select(EVTYPE, HEALTH, ECONOMIC)

colnames(analysisDF) <- c('EVTYPE', 'HEALTH', 'ECONOMIC')


if (VERBOSE) {
  print("This is the complete analysis table before it is divided into ")
  print("tables for damage types ")
  print(object.size(analysisDF))
  print(dim(analysisDF))
  print(head(analysisDF))
  # write.csv(analysisDF, "./analysis.csv")

}

```

### Transformation 7: Group the data by EVTYPE

```{r}

analysisTable <- analysisDF %>% group_by(EVTYPE) %>% 
  summarise_at(c("HEALTH", "ECONOMIC"), sum) %>% 
  arrange(.$EVTYPE, .by_group = TRUE)

if (VERBOSE) {
  print("This is the complete analysis table before it is divided into ")
  print("tables for damage types ")
  analysisDF <- data.frame(analysisTable)
  print(object.size(analysisTable))
  print(dim(analysisTable))
  print(head(analysisTable, n=46))
}

```

### Transformation 8:  Creating the "Damage Tables"

```{r}

damageTables = list()

DAMAGE_ORDERING = c("desc(.$HEALTH)", "desc(.$ECONOMIC)")

for (damage in HEALTH_IDX:ECONOMIC_IDX) {
  table <- analysisTable %>%
    arrange(eval(parse(text=DAMAGE_ORDERING[damage])), .by_group = TRUE)
  totalValue <- sum(table[, damage + 1])


  if (VERBOSE) {
    print(paste0("Damage table ", damage))
    print(object.size(table))
    print(dim(table))
    print(head(table))
  }

  accumulator     <- 0
  percentList     <- list()
  accumulatorList <- list()

  for (i in 1:length(table$EVTYPE)) {
    percent <- table[i, damage + 1]*100/totalValue
    accumulator <- accumulator + percent
    percentList <- append(percentList, percent)
    accumulatorList <- append(accumulatorList, accumulator)
  }
   table$PERCENT <- as.numeric(unlist(percentList))
   table$ACC_PERCENT <- as.numeric(unlist(accumulatorList))

  if (damage == HEALTH_IDX) {
     worstHEALTH <- table
  } else if (damage == ECONOMIC_IDX) {
     worstLosses <- table
  }

  if (VERBOSE) {
    print(paste0("Damage table with percentage ", damage))
    print(object.size(table))
    print(dim(table))
    print(head(table, n=15))
  }

  damageTables <- list.append(damageTables, table)

  if (VERBOSE) {
    print(paste0("Damage table with percentage ", damage))
    print(object.size(table))
    print(dim(table))
    print(damageTables)
  }
} # end of for loop
```


```{r}
barPlot <- function (damageTable, damageType)
{
  if (VERBOSE) {
    print(paste0("Damage table with percentage ", damageType))
    print(paste0("DAMAGE_SELECT[[damageType] ", DAMAGE_SELECT[[damageType]]))
    print(object.size(damageTable))
    print(dim(damageTable))
    print(damageTable)
  }
  table <- head(damageTable, n=10) %>%
    # select(EVTYPE, HEALTH)
  select(eval(parse(text = DAMAGE_SELECT[[damageType]])))
  colnames(table) <- eval(parse(text = AXIS_NAMES[[damageType]]))
  table$EVTYPE <- factor(table$EVTYPE, levels = table$EVTYPE)
  if (VERBOSE) {
    print(paste0("Damage table with percentage ", damageType))
    print(object.size(table))
    print(dim(table))
    print(table)
  }

  plt <- ggplot(table,
                aes(x = eval(parse(text=DAMAGE_REORDER[[damageType]])),
                    y = eval(parse(text=DAMAGE_NAMES[[damageType]])))) +
    ggtitle(paste0("Figure ", damageType,". United States Storm Related ",
                   str_to_title(DAMAGE_NAMES[[damageType]]))) +
    xlab("Events") +
    ylab(DAMAGE_NAMES[damageType]) +
    geom_bar(stat="identity", width=0.7, fill="steelblue") +
    theme(plot.title = element_text(face="plain", color="black", size=12),
          axis.text.x = element_text(size = 5, face="bold"),
          axis.text.y = element_text(size = 5, face="bold"),
          axis.title.x = element_text(size = 8, face="bold"),
          axis.title.y = element_text(size = 8, face="bold"))
  save_plot(paste0("EVTYPE_v_HEALTH-0", damageType, ".png"), plt)
}

```

```{r}
scatterPlot <- function (damageTables, damageType)
{

  set <- c(head(damageTables[[1]]$EVTYPE, n = 10),
                head(damageTables[[2]]$EVTYPE, n = 10))
  eventSet <- unique(set)
  

  bigEvt <- analysisTable[analysisTable$EVTYPE %in% eventSet,  ]
  
  plt <- ggplot(analysisTable, aes(x = HEALTH, y = ECONOMIC)) +
    ggtitle(
      paste0("Figure 3. United States  HEALTH vs. Economic Losses")) +
    xlab("Event Type") + ylab("Losses ($ millions)") +
    theme(plot.title = element_text(face="plain", color="black", size=28),
          axis.title.x = element_text(face="bold", color="black", size=14),
          axis.title.y = element_text(face="bold", color="black", size=14),
          axis.text = element_text(size = 10, face="bold")) +
    geom_point(data =
                 analysisTable[!(analysisTable$EVTYPE %in% eventSet),  ],
               aes(x = HEALTH, y = ECONOMIC, size = 3) +
                 theme(legend.position="none")) +
    geom_point(data = analysisTable[analysisTable$EVTYPE %in% eventSet,  ],
           aes(x = HEALTH, y = ECONOMIC, color = EVTYPE, size = 3)) +
    geom_smooth(method = lm) +
    geom_text_repel (
      data = bigEvt,
      aes(x=HEALTH, y=ECONOMIC, label = EVTYPE, color = EVTYPE, fontface = "bold"),
      min.segment.length = 0.0, nudge_y = 10.0, nudge_x = 100.0,
      force = 40.0,
      force_pull = 1.0
    )
  
  save_plot("HEALTH_v_ECONOMIC.png", plt, ncol = 2, nrow = 2)
}

```

```{r}

getTable <- function (damageTable, damageType)
{
  damageTable <- damageTable %>%
    select(eval(parse(text = TABLE_FIELDS[[damageType]])))

  resTable <- knitr::kable(head(damageTable, n = 50), "html",
    caption = paste0("<center><strong><font size='1'>",
                     "Table ", damageType,". United States ",
                     AXIS_LABELS[[damageType]][2],
                     "</font><center></strong>"),
    digits = 3, align = "lrrr",
    col.names = c(AXIS_LABELS[[damageType]]), row.names = TRUE
    ) %>%
    kable_styling(bootstrap_options = c("striped", "hover"),
                  full_width = F,
                  position = "left",
                  font_size = 10) %>%
    column_spec(column=1, width="1cm") %>%
    column_spec(column=2, width="3cm") %>%
    column_spec(column=3, width="2cm") %>%
    column_spec(column=4, width="2cm") %>%
    kable_classic_2()

  if (VERBOSE) {
    print(paste0("Damage table with percentage ", damageType))
    print(object.size(damageTable))
    print(dim(damageTable))
    print(damageTable)
  }

  return (resTable)

}

```



```{r images}

barPlot(damageTables[[HEALTH_IDX]], HEALTH_IDX)
barPlot(damageTables[[ECONOMIC_IDX]], ECONOMIC_IDX)
scatterPlot(damageTables)

casualtyTable <- getTable(damageTables[[HEALTH_IDX]], HEALTH_IDX)
lossesTable   <- getTable(damageTables[[ECONOMIC_IDX]], ECONOMIC_IDX)

```



<hr style="background: DarkOrchid; height: 3px"/>

# Results

```{r}


```

The United States has a variety of weather events ranging from the extreme cold and extreme heat, extreme precipitation and lack of precipitation, tornadoes, hurricanes, etc. To understand the impact of these events, the National Oceanographic and Atmospheric Administration (NOAA) collects and analyzes weather data from all over the country. The data are restricted to forty-eight "significant weather phenomena[1]" and associated data. Part of the collected information induces the number of HEALTH (deaths and injuries) and the amount of damage to property including crop damage.

StormCloud was produced to provide emergency services planners information regarding the damage to human life and the financial losses of specific weather events. Using this information, planners can help mitigate the damage by understanding the damages of these events. To this end, StormCloud presents presents the damages for storm damage as independent sets of data, one describing the human damage, and the other describing the financial damage.

In Table 1a, the list of weather related HEALTH from 1950 to approximately 2012. The numbers range from 0 \~ 97,000 deaths or injuries. From the data in Table 1a, tornadoes are the leading cause of weather related HEALTH in the United States with 96,907 dead or injured followed by "Excessive Heat" with \~12,363 dead or injured. Comparing the relative seriousness of weather events, tornadoes represent 62% of all HEALTH. In fact, 90% of all US weather related HEALTH happen with the eight worst weather events and 99% happen with the worst 21 events.

Table 1b is a list of weather related financial losses. Again, tornadoes are the biggest economic with approximately \$52 billion in losses from 1950 to 2012. This amounts to 27% of all weather related losses, which is significantly less proportion of HEALTH caused by tornadoes. The first nine events from Table 1b account for 90% of weather related financial losses compared to eight for HEALTH. The 99% level for financial losses happens in the first 19 events compared to 21 for HEALTH.

The weather events tables 1a and 1b show the number of HEALTH and the financial losses due to those events gives an overall picture of the damage caused by severe weather, but the dramatic differences between event types and types of damage within an event type are difficult to discern. Figure 1 shows an eight-fold difference in HEALTH between "Excessive Heat" and "Tornado". In contrast, Figure 2 shows a two-fold difference between in economic loss between "Flood" and "Tornado". The second event type differs between HEALTH and economic loss, which raises an interesting question. Since the worst events associated with public health are different then the events associated with economic losses, how should planners adapt their emergency response to based on the resources required by these different emergencies. Figure 3 is a plot of HEALTH versus economic losses. As with all of the data in this study, tornadoes are far worst than any other weather event, but which event is the second worst? This is a judgment call for the planners, but StormCloud the plot in Figure 3, gives planners a tool to help assess how to distribute resources and to request resources from government agencies.

The U.S. Federal Emergency Management Agency (FEMA) places the Valuation of Statistical Life (VSL) at \$12.5 million [2] based on a U.S. Department of Transportation memo [3]. With this information, emergency planners could monetize the value of a human life. In addition to the VSL, FEMA also uses the Abbreviated Injury Scale (AIS) to monetize the damage of injuries based on their seriousness. By monetizing deaths and injuries, the HEALTH versus Economic Loss plot could include a line dividing the amount of given resources required by an emergency response.

## Weather Related Damages
```{r, message=TRUE, echo = TRUE}
casualtyTable
```

```{r, message=TRUE, echo = TRUE}
lossesTable
```

## Graphs

## Worst Weather Related Causes of HEALTH

```{r, message=TRUE, echo = TRUE}
    knitr::include_graphics("EVTYPE_v_HEALTH-01.png")
```

## Worst Weather Related Causes of Economic Losses

```{r, message=TRUE, echo = TRUE}
    knitr::include_graphics("EVTYPE_v_HEALTH-02.png")
```

## Comparison of Causalties and Economic Losses

```{r, message=TRUE, echo = TRUE}
    knitr::include_graphics("HEALTH_v_ECONOMIC.png")
```

<hr style="background:#36013F; height:30px"/>

# Bibliography

[a] <https://www.ncdc.noaa.gov/stormevents/>
[b] NATIONAL WEATHER SERVICE INSTRUCTION 10-1605 downloaded from <https://www.nws.noaa.gov/directives/sym/pd01016005curr.pdf> on July 8, 2023

[2] <https://www.fema.gov/sites/default/files/documents/fema_standard-economic-values-methodology-report_092022.pdf>

[3] <https://www.transportation.gov/office-policy/transportation-policy/revised-departmental-guidance-on-valuation-of-a-statistical-life-in-economic-analysis> Source of FEMA's VSL data

# Appendicies

## Appendix I: Improvements

1. Actuarial data Time series data (analysis, we have the data) 
2. Complete reports regarding injury types and seriousness 
3. Create an online/tablet form to ensure consistent data collection
4. Clean up and streamline the code.
 